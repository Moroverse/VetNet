# Testing Strategy and Implementation

## Overview

This document outlines the comprehensive testing strategy for VetNet, leveraging iOS 26's Swift Testing framework, Mockable service testing, and ViewInspector for SwiftUI component validation. The strategy emphasizes accessibility-first testing, modular isolation, and performance validation.

Related documents: [01-modular-design.md](01-modular-design.md) | [03-feature-modules.md](03-feature-modules.md) | [08-security-performance.md](08-security-performance.md)

## iOS 26 Testing Architecture

### Swift Testing Framework Integration

The testing architecture leverages Swift Testing framework for modern async/await patterns and clear test organization.

```swift
// Tests/SchedulingTests/SchedulingEngineTests.swift
import Testing
import Mockable

@Suite(\"Veterinary Scheduling Intelligence\")
struct SchedulingEngineTests {
    
    @Test(\"VTL Triage Assessment Accuracy\")
    func testVTLTriageAssessment() async throws {
        // Given
        let mockTriageService = MockTriageService()
        let engine = SchedulingEngine(triageService: mockTriageService)
        let symptoms = [Symptom.lameness, Symptom.pain]
        let vitalSigns = VitalSigns(heartRate: 120, temperature: 102.5)
        
        // Configure mock behavior
        mockTriageService.assessUrgencyReturnValue = VTLUrgencyLevel.yellow
        
        // When\n        let assessment = await engine.assessCase(\n            symptoms: symptoms,\n            vitalSigns: vitalSigns\n        )\n        \n        // Then\n        #expect(assessment.vtlLevel == .yellow)\n        #expect(assessment.specialistRecommendations.contains(.orthopedic))\n        #expect(assessment.confidence > 0.8)\n        \n        // Verify mock interactions\n        #expect(mockTriageService.assessUrgencyCallsCount == 1)\n        #expect(mockTriageService.assessUrgencyReceivedArguments?.symptoms == symptoms)\n    }\n    \n    @Test(\"Specialist Matching Algorithm Performance\")\n    func testSpecialistMatchingPerformance() async throws {\n        // Performance testing for complex scheduling scenarios\n        let specialists = createTestSpecialists(count: 20)\n        let appointments = createTestAppointments(count: 100)\n        let engine = SchedulingEngine()\n        \n        let startTime = CFAbsoluteTimeGetCurrent()\n        let result = await engine.optimizeSchedule(\n            specialists: specialists, \n            appointments: appointments\n        )\n        let executionTime = CFAbsoluteTimeGetCurrent() - startTime\n        \n        // Performance requirements from PRD\n        #expect(executionTime < 1.0, \"Must complete within 1 second per PRD requirements\")\n        #expect(result.optimizationScore > 0.8, \"High-quality optimization required\")\n        #expect(result.conflicts.isEmpty, \"No scheduling conflicts should remain\")\n    }\n    \n    @Test(\"Emergency Case Fast-Track Processing\")\n    func testEmergencyFastTrack() async throws {\n        let emergencyAssessment = TriageAssessment(\n            vtlLevel: .red,\n            symptoms: [.respiratory_distress, .cardiac_emergency],\n            urgentCare: true\n        )\n        \n        let engine = SchedulingEngine()\n        let startTime = Date()\n        \n        let result = await engine.processEmergencyCase(emergencyAssessment)\n        let processingTime = Date().timeIntervalSince(startTime)\n        \n        #expect(processingTime < 0.5, \"Emergency cases must be processed within 500ms\")\n        #expect(result.appointmentSlot != nil, \"Emergency slot must be allocated\")\n        #expect(result.specialistNotified, \"Specialist must be automatically notified\")\n    }\n}\n```\n\n### Mockable Service Testing\n\nMockable provides protocol-based service mocking for isolated unit testing.\n\n```swift\n// Tests/Mocks/MockableServices.swift\nimport Mockable\n\n@Mockable\nprotocol TriageService {\n    func assessUrgency(symptoms: [Symptom], vitals: VitalSigns) async -> VTLUrgencyLevel\n    func calculateComplexity(assessment: TriageAssessment) async -> Float\n    func recommendSpecialists(assessment: TriageAssessment) async -> [SpecialistRecommendation]\n}\n\n@Mockable\nprotocol SpecialistMatchingService {\n    func findOptimalMatch(\n        assessment: TriageAssessment, \n        specialists: [Specialist]\n    ) async -> SpecialistMatchResult\n    func balanceWorkload(specialists: [Specialist]) async -> WorkloadOptimization\n    func checkAvailability(specialist: Specialist, timeSlot: TimeSlot) async -> Bool\n}\n\n@Mockable\nprotocol PatientRecordsService {\n    func getPatient(_ id: UUID) async throws -> Patient\n    func updateMedicalHistory(_ id: UUID, record: MedicalRecord) async throws\n    func searchPatients(criteria: SearchCriteria) async -> [PatientSummary]\n}\n\n// Mock usage in tests\n@Suite(\"Triage Module Tests\")\nstruct TriageModuleTests {\n    \n    @Test(\"Complex Case Assessment with Medical History\")\n    func testComplexCaseAssessment() async throws {\n        // Setup mocks\n        let mockTriageService = MockTriageService()\n        let mockPatientService = MockPatientRecordsService()\n        \n        let patient = createTestPatient(withComplexHistory: true)\n        let symptoms = [Symptom.neurologicalSymptoms, Symptom.behaviorChanges]\n        \n        // Configure mock responses\n        mockPatientService.getPatientReturnValue = patient\n        mockTriageService.assessUrgencyReturnValue = .orange\n        mockTriageService.calculateComplexityReturnValue = 0.85\n        \n        // Execute test\n        let triageModule = TriageModule(\n            triageService: mockTriageService,\n            patientService: mockPatientService\n        )\n        \n        let assessment = try await triageModule.conductFullAssessment(\n            patientId: patient.id,\n            symptoms: symptoms\n        )\n        \n        // Verify results\n        #expect(assessment.vtlLevel == .orange)\n        #expect(assessment.complexityScore > 0.8)\n        #expect(assessment.takesHistoryIntoAccount)\n        \n        // Verify service interactions\n        #expect(mockPatientService.getPatientCallsCount == 1)\n        #expect(mockTriageService.assessUrgencyCallsCount == 1)\n        #expect(mockTriageService.calculateComplexityCallsCount == 1)\n    }\n}\n```\n\n## ViewInspector SwiftUI Testing with Accessibility Identifiers\n\nViewInspector enables comprehensive SwiftUI component testing with accessibility-first approaches.\n\n```swift\n// Tests/SwiftUITests/ComponentTests.swift\nimport ViewInspector\nimport Testing\nimport SwiftUI\n\n@Suite(\"SwiftUI Component Testing\")\nstruct SwiftUIComponentTests {\n    \n    @Test(\"Glass Schedule Calendar Component Testing\")\n    func testGlassScheduleCalendarComponents() throws {\n        let testAppointments = createTestAppointments()\n        let calendar = GlassScheduleCalendar(appointments: testAppointments)\n        \n        // Find components using accessibility identifiers - most reliable approach\n        let calendarGrid = try calendar.inspect().find(\n            viewWithAccessibilityIdentifier: \"schedule_calendar_grid\"\n        )\n        #expect(calendarGrid != nil, \"Calendar grid should be present\")\n        \n        let appointmentList = try calendar.inspect().find(\n            viewWithAccessibilityIdentifier: \"appointment_list_view\"\n        )\n        #expect(appointmentList != nil, \"Appointment list should be present\")\n        \n        // Test glass effect container\n        let glassContainer = try calendar.inspect().find(\n            viewWithAccessibilityIdentifier: \"glass_schedule_container\"\n        )\n        #expect(glassContainer != nil, \"Glass container should be present\")\n        \n        // Verify calendar shows correct number of appointments\n        let appointmentCells = try calendar.inspect().findAll(\n            viewWithAccessibilityIdentifier: \"appointment_cell\"\n        )\n        #expect(appointmentCells.count == testAppointments.count)\n    }\n    \n    @Test(\"Specialist Card Interaction Testing\")\n    func testSpecialistCardInteraction() throws {\n        let specialist = createTestSpecialist(name: \"Dr. Smith\", credentials: \"DVM\")\n        let card = GlassSpecialistCard(specialist: specialist)\n        \n        // Use accessibility identifiers for reliable component finding\n        let selectButton = try card.inspect().find(\n            viewWithAccessibilityIdentifier: \"specialist_select_button_\\(specialist.id)\"\n        )\n        let specialistName = try card.inspect().find(\n            viewWithAccessibilityIdentifier: \"specialist_name_label\"\n        )\n        let specialistCredentials = try card.inspect().find(\n            viewWithAccessibilityIdentifier: \"specialist_credentials_label\"\n        )\n        \n        // Test component content\n        #expect(try specialistName.text().string() == \"Dr. Smith\")\n        #expect(try specialistCredentials.text().string() == \"DVM\")\n        \n        // Test accessibility properties\n        #expect(\n            try selectButton.accessibilityLabel() == \"Select Dr. Smith for appointment\",\n            \"Accessibility label should be descriptive\"\n        )\n        #expect(\n            try selectButton.accessibilityIdentifier() == \"specialist_select_button_\\(specialist.id)\",\n            \"Accessibility identifier should be unique and consistent\"\n        )\n        \n        // Test button interaction\n        var buttonTapped = false\n        let cardWithAction = GlassSpecialistCard(specialist: specialist) {\n            buttonTapped = true\n        }\n        \n        try cardWithAction.inspect().find(\n            viewWithAccessibilityIdentifier: \"specialist_select_button_\\(specialist.id)\"\n        ).button().tap()\n        \n        #expect(buttonTapped, \"Button tap should trigger action\")\n    }\n    \n    @Test(\"Triage Form Components and Validation\")\n    func testTriageFormComponents() throws {\n        let patient = createTestPatient()\n        let triageForm = GlassTriageForm(patient: patient)\n        \n        // Find form elements using accessibility identifiers\n        let urgencyPicker = try triageForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"triage_urgency_picker\"\n        )\n        let symptomsTextEditor = try triageForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"triage_symptoms_input\"\n        )\n        let submitButton = try triageForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"triage_submit_button\"\n        )\n        let cancelButton = try triageForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"triage_cancel_button\"\n        )\n        \n        // Test initial form state\n        #expect(try submitButton.button().isDisabled(), \"Submit should be disabled initially\")\n        \n        // Test form interactions\n        try urgencyPicker.picker().select(value: VTLUrgencyLevel.yellow)\n        try symptomsTextEditor.textEditor().setText(\"Patient showing signs of lameness\")\n        \n        // Verify submit button becomes enabled after valid input\n        #expect(\n            try submitButton.button().isDisabled() == false,\n            \"Submit button should be enabled with valid input\"\n        )\n        \n        // Test QuickForm integration components\n        let quickFormContainer = try triageForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"quickform_container\"\n        )\n        #expect(quickFormContainer != nil, \"QuickForm container should be present\")\n        \n        // Test dynamic form sections based on urgency level\n        let vitalSignsSection = try triageForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"vital_signs_section\"\n        )\n        #expect(vitalSignsSection != nil, \"Vital signs section should appear for yellow urgency\")\n    }\n    \n    @Test(\"Navigation Flow Testing with Accessibility\")\n    func testNavigationWithAccessibilityIds() throws {\n        let navigationController = VeterinaryNavigationController()\n        let rootView = SchedulingRootView()\n            .environmentObject(navigationController)\n        \n        // Find navigation elements using accessibility identifiers\n        let scheduleTab = try rootView.inspect().find(\n            viewWithAccessibilityIdentifier: \"tab_schedule\"\n        )\n        let patientsTab = try rootView.inspect().find(\n            viewWithAccessibilityIdentifier: \"tab_patients\"\n        )\n        let addAppointmentButton = try rootView.inspect().find(\n            viewWithAccessibilityIdentifier: \"add_appointment_button\"\n        )\n        \n        // Test tab navigation\n        try scheduleTab.button().tap()\n        #expect(navigationController.currentTab == .schedule)\n        \n        // Test appointment creation flow\n        try addAppointmentButton.button().tap()\n        #expect(navigationController.navigationPath.count == 1)\n        \n        // Verify accessibility labels for VoiceOver\n        #expect(\n            try scheduleTab.accessibilityLabel() == \"Schedule appointments\",\n            \"Tab should have descriptive accessibility label\"\n        )\n        #expect(\n            try patientsTab.accessibilityLabel() == \"View patient records\",\n            \"Tab should have descriptive accessibility label\"\n        )\n    }\n    \n    @Test(\"Emergency Triage UI State Testing\")\n    func testEmergencyTriageUIState() throws {\n        let emergencyAssessment = TriageAssessment(vtlLevel: .red)\n        let emergencyForm = EmergencyTriageForm(assessment: emergencyAssessment)\n        \n        // Verify emergency-specific styling\n        let emergencyContainer = try emergencyForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"emergency_triage_container\"\n        )\n        \n        // Test that emergency forms have distinctive visual treatment\n        let glassEffect = try emergencyContainer.modifier(GlassEffectModifier.self)\n        #expect(glassEffect.style.isEmergencyStyle, \"Emergency forms should have emergency glass styling\")\n        \n        // Test urgent action buttons\n        let immediateActionButton = try emergencyForm.inspect().find(\n            viewWithAccessibilityIdentifier: \"immediate_action_button\"\n        )\n        #expect(\n            try immediateActionButton.accessibilityTraits().contains(.startsMediaSession),\n            \"Emergency actions should have appropriate accessibility traits\"\n        )\n    }\n}\n```\n\n### Accessibility Testing Focus\n\n```swift\n@Suite(\"iOS 26 Accessibility Compliance\")\nstruct AccessibilityTests {\n    \n    @Test(\"Liquid Glass VoiceOver Compatibility\")\n    func testGlassComponentsAccessibility() async throws {\n        let glassCalendar = GlassScheduleCalendar(appointments: [])\n        \n        // Verify VoiceOver navigation works with glass effects\n        let calendarView = try glassCalendar.inspect()\n        #expect(calendarView.accessibilityLabel != nil, \"Glass components must have accessibility labels\")\n        #expect(\n            calendarView.accessibilityTraits.contains(.allowsDirectInteraction),\n            \"Interactive glass components should allow direct interaction\"\n        )\n        \n        // Test accessibility element grouping\n        let accessibilityElements = try calendarView.accessibilityElements()\n        #expect(accessibilityElements.count > 0, \"Should have accessible elements\")\n    }\n    \n    @Test(\"Dynamic Type Support\")\n    func testDynamicTypeCompatibility() async throws {\n        let testSizes: [DynamicTypeSize] = [\n            .medium,\n            .large,\n            .xLarge,\n            .accessibility1,\n            .accessibility5\n        ]\n        \n        for typeSize in testSizes {\n            let environment = EnvironmentValues()\n            environment.dynamicTypeSize = typeSize\n            \n            let view = PatientInfoCard(patient: createTestPatient())\n                .environment(\\.dynamicTypeSize, typeSize)\n            \n            // Ensure text remains readable at all sizes\n            let textElements = try view.inspect().findAll(Text.self)\n            for textElement in textElements {\n                let font = try textElement.attributes().font\n                #expect(\n                    font?.pointSize ?? 0 > 10,\n                    \"Text should remain readable at size \\(typeSize)\"\n                )\n            }\n        }\n    }\n    \n    @Test(\"VoiceOver Medical Terminology\")\n    func testMedicalTerminologyPronunciation() throws {\n        let medicalTerms = [\n            \"Dyspnea\": \"Disp-nee-ah\",\n            \"Tachycardia\": \"Tak-ih-kar-dee-ah\",\n            \"Bradycardia\": \"Brad-ih-kar-dee-ah\"\n        ]\n        \n        for (term, pronunciation) in medicalTerms {\n            let medicalLabel = Text(term)\n                .accessibilityPronunciation(pronunciation)\n            \n            let labelView = try medicalLabel.inspect()\n            #expect(\n                try labelView.accessibilityPronunciation() == pronunciation,\n                \"Medical terms should have correct pronunciation guide\"\n            )\n        }\n    }\n    \n    @Test(\"Accessibility Identifier Consistency\")\n    func testAccessibilityIdConsistency() throws {\n        // Test that all major components have proper accessibility identifiers\n        let calendar = GlassScheduleCalendar(appointments: [])\n        let specialist = createTestSpecialist()\n        let specialistCard = GlassSpecialistCard(specialist: specialist)\n        \n        // Define required accessibility identifiers\n        let requiredIds = [\n            \"schedule_calendar_grid\",\n            \"appointment_list_view\",\n            \"specialist_select_button_\\(specialist.id)\",\n            \"specialist_name_label\"\n        ]\n        \n        for identifier in requiredIds {\n            let calendarComponent = try? calendar.inspect().find(\n                viewWithAccessibilityIdentifier: identifier\n            )\n            let cardComponent = try? specialistCard.inspect().find(\n                viewWithAccessibilityIdentifier: identifier\n            )\n            \n            let componentFound = calendarComponent != nil || cardComponent != nil\n            #expect(componentFound, \"Missing accessibility identifier: \\(identifier)\")\n        }\n    }\n}\n```\n\n## Modular Testing Strategy\n\n### Module Isolation Testing\n\nEach module is tested in isolation with mocked dependencies to ensure clean boundaries.\n\n```swift\n@Suite(\"Scheduling Module Tests\")\nstruct SchedulingModuleTests {\n    // Mock infrastructure dependencies\n    let mockPersistence = MockPersistenceStore<Appointment>()\n    let mockEventBus = MockEventBus()\n    let mockCloudKit = MockCloudKitService()\n    \n    @Test(\"Schedule appointment with conflict detection\")\n    func testScheduleAppointmentWithConflict() async throws {\n        // Setup module with mocked dependencies\n        let module = SchedulingModule(\n            persistenceStore: mockPersistence,\n            eventBus: mockEventBus,\n            cloudKitService: mockCloudKit\n        )\n        \n        // Setup conflicting appointments\n        let existingAppointment = createTestAppointment(\n            time: Date(),\n            specialist: createTestSpecialist(id: UUID())\n        )\n        mockPersistence.saveReturnValue = ()\n        mockPersistence.queryReturnValue = [existingAppointment]\n        \n        // Attempt to schedule conflicting appointment\n        let conflictingRequest = ScheduleAppointmentRequest(\n            patientId: UUID(),\n            specialistId: existingAppointment.specialist!.specialistID,\n            scheduledTime: existingAppointment.scheduledDateTime,\n            estimatedDuration: .minutes(30)\n        )\n        \n        // Test conflict detection\n        do {\n            let result = try await module.scheduleAppointment(conflictingRequest)\n            #expect(result.status == .conflictDetected, \"Should detect scheduling conflict\")\n            #expect(result.alternativeSlots.count > 0, \"Should provide alternative slots\")\n        } catch {\n            #expect(Bool(false), \"Should handle conflicts gracefully, not throw\")\n        }\n    }\n    \n    @Test(\"Event publishing on successful appointment creation\")\n    func testEventPublishingOnAppointmentCreation() async throws {\n        let module = SchedulingModule(\n            persistenceStore: mockPersistence,\n            eventBus: mockEventBus,\n            cloudKitService: mockCloudKit\n        )\n        \n        mockPersistence.saveReturnValue = ()\n        mockPersistence.queryReturnValue = [] // No conflicts\n        \n        let request = ScheduleAppointmentRequest(\n            patientId: UUID(),\n            specialistId: UUID(),\n            scheduledTime: Date().addingTimeInterval(3600),\n            estimatedDuration: .minutes(30)\n        )\n        \n        let result = try await module.scheduleAppointment(request)\n        \n        #expect(result.status == .scheduled)\n        #expect(mockEventBus.publishCallsCount == 1)\n        \n        // Verify correct event was published\n        let publishedEvent = mockEventBus.publishReceivedArguments\n        #expect(publishedEvent is AppointmentScheduledEvent)\n    }\n}\n```\n\n### Inter-Module Integration Testing\n\n```swift\n@Suite(\"Module Integration Tests\")\nstruct ModuleIntegrationTests {\n    \n    @Test(\"Triage to Scheduling workflow\")\n    func testTriageToSchedulingIntegration() async throws {\n        // Use in-memory implementations for integration tests\n        let container = TestAppContainer()\n        \n        // Create test patient\n        let patient = createTestPatient()\n        let patientDTO = try await container.patientModule.createPatient(\n            CreatePatientRequest(from: patient)\n        )\n        \n        // Conduct triage assessment\n        let assessmentSession = try await container.triageModule.startAssessment(\n            for: patientDTO.id\n        )\n        \n        let triageSubmission = TriageSubmissionDTO(\n            sessionId: assessmentSession.sessionId,\n            symptoms: [.lameness, .pain],\n            vtlLevel: 3, // Yellow\n            vitalSigns: VitalSigns(heartRate: 100, temperature: 101.5)\n        )\n        \n        let triageResult = try await container.triageModule.submitAssessment(triageSubmission)\n        \n        // Create appointment from triage result\n        let schedulingRequest = SchedulingRequestDTO(\n            patientId: patientDTO.id,\n            triageAssessmentId: triageResult.assessmentId,\n            vtlLevel: triageResult.vtlLevel,\n            preferredSpecialists: triageResult.recommendedSpecialists,\n            estimatedDuration: .minutes(45)\n        )\n        \n        let appointment = try await container.schedulingModule.scheduleFromTriage(schedulingRequest)\n        \n        // Verify integration\n        #expect(appointment.patientId == patientDTO.id)\n        #expect(appointment.triageAssessmentId == triageResult.assessmentId)\n        #expect(VTLUrgencyLevel(rawValue: appointment.urgencyLevel) == VTLUrgencyLevel(rawValue: triageResult.vtlLevel))\n        \n        // Verify patient record was updated\n        let updatedPatient = try await container.patientModule.getPatient(patientDTO.id)\n        #expect(updatedPatient.lastAppointment == appointment.id)\n    }\n    \n    @Test(\"Emergency workflow end-to-end\")\n    func testEmergencyWorkflowIntegration() async throws {\n        let container = TestAppContainer()\n        \n        // Create emergency assessment\n        let emergencyAssessment = TriageSubmissionDTO(\n            sessionId: UUID(),\n            symptoms: [.respiratory_distress, .cardiac_emergency],\n            vtlLevel: 1, // Red - Emergency\n            vitalSigns: VitalSigns(heartRate: 180, temperature: 104.0)\n        )\n        \n        let triageResult = try await container.triageModule.submitAssessment(emergencyAssessment)\n        \n        // Emergency should trigger immediate scheduling\n        #expect(triageResult.urgentCare == true)\n        #expect(triageResult.vtlLevel == 1)\n        \n        // Verify emergency appointment was auto-created\n        let emergencyAppointments = await container.schedulingModule.getEmergencyAppointments()\n        #expect(emergencyAppointments.count == 1)\n        \n        let emergencyAppointment = emergencyAppointments.first!\n        #expect(emergencyAppointment.type == \"emergency\")\n        #expect(emergencyAppointment.scheduledDateTime <= Date().addingTimeInterval(900)) // Within 15 minutes\n    }\n}\n```\n\n## Performance Testing Strategy\n\n### Automated Performance Benchmarks\n\n```swift\n@Suite(\"Performance Testing\")\nstruct PerformanceTests {\n    \n    @Test(\"Scheduling Algorithm Scalability\")\n    func testSchedulingScalability() async throws {\n        let testCases = [\n            (specialists: 5, appointments: 50),\n            (specialists: 10, appointments: 100),\n            (specialists: 20, appointments: 200),\n            (specialists: 50, appointments: 500)\n        ]\n        \n        let engine = OptimizedSchedulingEngine()\n        \n        for (specialistCount, appointmentCount) in testCases {\n            let specialists = createTestSpecialists(count: specialistCount)\n            let appointments = createTestAppointments(count: appointmentCount)\n            \n            let startTime = CFAbsoluteTimeGetCurrent()\n            let result = await engine.calculateOptimalScheduling(\n                specialists: specialists,\n                appointments: appointments\n            )\n            let executionTime = CFAbsoluteTimeGetCurrent() - startTime\n            \n            // Performance should scale reasonably\n            let expectedMaxTime = Double(appointmentCount) * 0.01 // 10ms per appointment max\n            #expect(\n                executionTime < expectedMaxTime,\n                \"Scheduling \\(appointmentCount) appointments with \\(specialistCount) specialists should complete in under \\(expectedMaxTime)s\"\n            )\n            \n            #expect(result.optimizationScore > 0.7, \"Quality should remain high at scale\")\n        }\n    }\n    \n    @Test(\"Memory usage during intensive operations\")\n    func testMemoryUsageDuringIntensiveOperations() async throws {\n        let initialMemory = getCurrentMemoryUsage()\n        \n        // Simulate heavy scheduling operations\n        let specialists = createTestSpecialists(count: 100)\n        let appointments = createTestAppointments(count: 1000)\n        \n        let engine = OptimizedSchedulingEngine()\n        \n        // Perform multiple optimization cycles\n        for _ in 0..<10 {\n            _ = await engine.calculateOptimalScheduling(\n                specialists: specialists,\n                appointments: appointments\n            )\n        }\n        \n        let peakMemory = getCurrentMemoryUsage()\n        let memoryIncrease = peakMemory - initialMemory\n        \n        // Memory increase should be reasonable (less than 100MB)\n        #expect(\n            memoryIncrease < 100 * 1024 * 1024,\n            \"Memory usage should remain controlled during intensive operations\"\n        )\n        \n        // Allow memory cleanup\n        await Task.sleep(nanoseconds: 1_000_000_000) // 1 second\n        \n        let finalMemory = getCurrentMemoryUsage()\n        let memoryLeak = finalMemory - initialMemory\n        \n        // Should not have significant memory leaks\n        #expect(\n            memoryLeak < 20 * 1024 * 1024,\n            \"Should not have significant memory leaks (< 20MB)\"\n        )\n    }\n}\n```\n\n## Security Testing\n\n### HIPAA Compliance Testing\n\n```swift\n@Suite(\"Security and HIPAA Compliance\")\nstruct SecurityTests {\n    \n    @Test(\"Data encryption and decryption\")\n    func testDataEncryption() throws {\n        let dataProtection = VeterinaryDataProtection(practiceId: UUID())\n        let sensitiveData = \"Patient John Doe, Medical Record: Diabetes Type 2\".data(using: .utf8)!\n        \n        // Test encryption\n        let encryptedData = try dataProtection.encryptPatientData(\n            sensitiveData,\n            classification: .restrictedPHI\n        )\n        \n        // Encrypted data should be different from original\n        #expect(encryptedData.combined != sensitiveData)\n        \n        // Test decryption\n        let decryptedData = try dataProtection.decryptPatientData(\n            encryptedData,\n            requestedBy: UUID()\n        )\n        \n        #expect(decryptedData == sensitiveData, \"Decrypted data should match original\")\n    }\n    \n    @Test(\"Access control enforcement\")\n    func testAccessControlEnforcement() async throws {\n        let accessController = RoleBasedAccessController()\n        \n        let veterinarianId = UUID()\n        let staffId = UUID()\n        \n        // Setup user roles\n        try await accessController.setUserRole(veterinarianId, role: .veterinarian)\n        try await accessController.setUserRole(staffId, role: .staff)\n        \n        // Test veterinarian access to PHI\n        let veterinarianHasAccess = try accessController.verifyAccess(\n            userId: veterinarianId,\n            dataClassification: .restrictedPHI,\n            operation: .write\n        )\n        #expect(veterinarianHasAccess, \"Veterinarians should have write access to PHI\")\n        \n        // Test staff access restrictions\n        do {\n            try accessController.verifyAccess(\n                userId: staffId,\n                dataClassification: .restrictedPHI,\n                operation: .write\n            )\n            #expect(Bool(false), \"Staff should not have write access to PHI\")\n        } catch AccessControlError.insufficientPermissions {\n            // Expected behavior\n        }\n    }\n    \n    @Test(\"Audit trail logging\")\n    func testAuditTrailLogging() async throws {\n        let practiceId = UUID()\n        let auditLogger = HIPAAAuditLogger(practiceId: practiceId)\n        let mockAuditStore = MockAuditLogStore()\n        \n        // Replace audit store with mock for testing\n        auditLogger.auditStore = mockAuditStore\n        \n        let userId = UUID()\n        let timestamp = Date()\n        \n        // Test data access logging\n        auditLogger.logAccess(\n            userId: userId,\n            dataClassification: .restrictedPHI,\n            operation: .read,\n            timestamp: timestamp\n        )\n        \n        // Verify audit entry was created\n        #expect(mockAuditStore.storeCallsCount == 1)\n        \n        let storedEntry = mockAuditStore.storeReceivedArguments!\n        #expect(storedEntry.userId == userId)\n        #expect(storedEntry.eventType == .dataAccess)\n        #expect(storedEntry.dataClassification == .restrictedPHI)\n    }\n}\n```\n\n## Test Organization and Execution\n\n### Test Suite Structure\n\n```\nTests/\n├── UnitTests/\n│   ├── SchedulingTests/\n│   │   ├── SchedulingEngineTests.swift\n│   │   ├── ConflictResolverTests.swift\n│   │   └── WorkloadBalancerTests.swift\n│   ├── TriageTests/\n│   │   ├── VTLProtocolTests.swift\n│   │   ├── ComplexityScorerTests.swift\n│   │   └── ABCDEAssessmentTests.swift\n│   └── PatientRecordsTests/\n├── IntegrationTests/\n│   ├── ModuleIntegrationTests.swift\n│   ├── WorkflowIntegrationTests.swift\n│   └── DataFlowIntegrationTests.swift\n├── SwiftUITests/\n│   ├── ComponentTests.swift\n│   ├── AccessibilityTests.swift\n│   └── NavigationTests.swift\n├── PerformanceTests/\n│   ├── SchedulingPerformanceTests.swift\n│   ├── MemoryUsageTests.swift\n│   └── UIPerformanceTests.swift\n└── SecurityTests/\n    ├── EncryptionTests.swift\n    ├── AccessControlTests.swift\n    └── AuditTrailTests.swift\n```\n\n### Continuous Integration Testing\n\n```yaml\n# .github/workflows/tests.yml\nname: VetNet Test Suite\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: macos-14\n    steps:\n    - uses: actions/checkout@v4\n    \n    - name: Select Xcode version\n      run: sudo xcode-select -s /Applications/Xcode_26.0.app/Contents/Developer\n    \n    - name: Run Unit Tests\n      run: |\n        xcodebuild test \\\n          -scheme VetNet \\\n          -destination 'platform=iOS Simulator,name=iPad Pro (12.9-inch) (6th generation),OS=18.0' \\\n          -testPlan UnitTests\n    \n    - name: Run Integration Tests\n      run: |\n        xcodebuild test \\\n          -scheme VetNet \\\n          -destination 'platform=iOS Simulator,name=iPad Pro (12.9-inch) (6th generation),OS=18.0' \\\n          -testPlan IntegrationTests\n    \n    - name: Run Performance Tests\n      run: |\n        xcodebuild test \\\n          -scheme VetNet \\\n          -destination 'platform=iOS Simulator,name=iPad Pro (12.9-inch) (6th generation),OS=18.0' \\\n          -testPlan PerformanceTests\n    \n    - name: Generate Test Report\n      run: |\n        xcrun xccov view --report --json DerivedData/Build/ProfileData/*.xccovreport > coverage.json\n    \n    - name: Upload Coverage Reports\n      uses: codecov/codecov-action@v3\n      with:\n        files: coverage.json\n```\n\n## Related Documentation\n\n- **[01-modular-design.md](01-modular-design.md)**: Module isolation and testing boundaries\n- **[03-feature-modules.md](03-feature-modules.md)**: Module interfaces and testing contracts\n- **[08-security-performance.md](08-security-performance.md)**: Security testing requirements and performance benchmarks\n- **[02-tech-stack.md](02-tech-stack.md)**: Testing framework choices and rationale

## QuickForm Testing Integration

### Form Validation Testing

QuickForm forms require specialized testing approaches for validation logic and reactive field relationships:

```swift
@Suite("QuickForm Testing")
struct QuickFormTests {
    
    @Test("Patient form validation testing")
    func testPatientFormValidation() throws {
        let model = PatientFormViewModel()
        
        // Test empty form validation
        let emptyResult = model.validate()
        #expect(\!emptyResult.isValid)
        #expect(emptyResult.errors.contains { $0.contains("Patient Name") })
        
        // Test valid form
        model.name.value = "Max"
        model.species.value = .dog
        
        let validResult = model.validate()
        #expect(validResult.isValid)
    }
    
    @Test("Form UI responds to validation")
    func testFormUIValidation() throws {
        let view = PatientFormView()
        
        let nameField = try view.inspect()
            .find(viewWithAccessibilityIdentifier: "patient_name_field")
        
        let saveButton = try view.inspect()
            .find(viewWithAccessibilityIdentifier: "save_patient_button")
        
        // Initially save button should be disabled due to validation
        #expect(\!try saveButton.button().isEnabled())
        
        // Fill required fields
        try nameField.textField().setValue("Max")
        
        // Now save button should be enabled
        #expect(try saveButton.button().isEnabled())
    }
    
    @Test("Reactive field relationships")
    func testReactiveFieldRelationships() async throws {
        let model = PatientFormViewModel()
        
        // Change species should trigger breed field update
        model.species.value = .dog
        
        // Wait for reactive update
        try await Task.sleep(for: .milliseconds(100))
        
        // Breed options should be updated for dogs
        #expect(model.breed.allValues.contains { $0.name == "Labrador" })
    }
}
```

### Testing QuickForm Components with ViewInspector

```swift
@Test("QuickForm UI component testing")
func testQuickFormComponents() throws {
    let patient = createTestPatient()
    let formView = PatientFormView(viewModel: PatientFormViewModel())
    
    // Test QuickForm-generated components
    let formContainer = try formView.inspect().find(
        viewWithAccessibilityIdentifier: "quickform_container"
    )
    #expect(formContainer \!= nil, "QuickForm container should be present")
    
    // Test validation feedback UI
    let validationFeedback = try formView.inspect().find(
        viewWithAccessibilityIdentifier: "validation_feedback"
    )
    #expect(validationFeedback \!= nil, "Validation feedback should be visible")
    
    // Test reactive form sections
    let conditionalSection = try formView.inspect().find(
        viewWithAccessibilityIdentifier: "conditional_form_section"
    )
    #expect(conditionalSection \!= nil, "Conditional sections should render properly")
}
```

### Async Field Testing

```swift
@Test("Async picker field testing")
func testAsyncPickerFields() async throws {
    let mockBreedService = MockBreedService()
    let expectedBreeds = [Breed(name: "Labrador"), Breed(name: "Golden Retriever")]
    
    given(mockBreedService)
        .searchBreeds(species: .any, query: .any)
        .willReturn(expectedBreeds)
    
    let model = PatientFormViewModel(breedService: mockBreedService)
    model.species.value = .dog
    
    // Wait for async breed loading
    try await Task.sleep(for: .milliseconds(100))
    
    #expect(model.breed.allValues == expectedBreeds)
}
```

- **[quickform-integration.md](quickform-integration.md)**: QuickForm testing patterns and integration examples
