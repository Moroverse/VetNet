# Story 1.1: Patient Creation & Profile Management

## Status
Approved

## Story
**As a** veterinary practice staff member,  
**I want to** create and manage patient profiles with essential information,  
**so that** I can maintain accurate patient records for scheduling and medical care.

## Acceptance Criteria

1. **UI Layer**
   - Patient creation form with fields:
     - Name (required)
     - Species (required, dropdown)
     - Breed (required, filtered by species)
     - Date of birth (required, date picker)
     - Weight (optional, with units)
     - Owner information (required)
     - Medical ID (auto-generated)
     - Microchip number (optional)
     - Notes (optional, multiline)
   - Form validation with inline errors
   - Save/Cancel actions
   - Loading states during save
   - Success confirmation

2. **Business Layer**
   - Patient domain model with:
     - Validation rules for all fields
     - Age calculation from birth date
     - Species-specific breed validation
     - Medical ID generation algorithm
     - Data transformation for persistence
   - Business rules enforcement:
     - Future birth dates not allowed
     - Weight within species ranges
     - Owner relationship validation

3. **Data Layer**
   - SwiftData Patient entity with:
     - CloudKit synchronization
     - Compound uniqueness constraints
     - Automatic timestamps
     - Soft delete support
   - Relationships:
     - Owner (many-to-one)
     - Appointments (one-to-many)
     - Medical records (one-to-many)

4. **Infrastructure**
   - Complete iOS project setup:
     - Swift 6.2+ configuration
     - Factory DI container setup
     - SwiftUIRouting integration
     - Liquid Glass design system
   - Development environment:
     - Tuist configuration
     - Git repository setup
     - CI/CD pipeline foundation

5. **Mock Services**
   - In-memory patient service with:
     - CRUD operations
     - Search functionality
     - Validation logic
     - Error simulation
   - Service protocol definition
   - Mockable integration

6. **Sample Data**
   - Pre-populated database with 20+ patients:
     - Dogs: Labrador (Max, Bella), German Shepherd (Rex, Luna), Golden Retriever (Charlie, Daisy)
     - Cats: Persian (Whiskers, Mittens), Maine Coon (Oliver, Sophie), Siamese (Leo, Cleo)
     - Exotic: Rabbit (Bunny), Parrot (Polly), Bearded Dragon (Spike), Guinea Pig (Patches)
   - Varied owner demographics
   - Realistic medical histories
   - Different age ranges

7. **Testing**
   - Unit tests:
     - Patient validation logic
     - Age calculation accuracy
     - Medical ID uniqueness
   - Integration tests:
     - Data persistence verification
     - CloudKit sync simulation
   - UI tests:
     - Form completion flow
     - Validation error display
     - Success path verification

8. **Feature Flag**
   - `patient_management_v1` controls:
     - Feature visibility
     - Mock vs. real data toggle
     - Progressive rollout
     - A/B testing capability

## Tasks / Subtasks

- [ ] **Project Foundation Setup** (AC: 4)
  - [ ] Configure Tuist project with Swift 6.2+ and iOS 26 targets
  - [ ] Set up Factory DI container for service management  
  - [ ] Integrate SwiftUIRouting navigation module
  - [ ] Configure Liquid Glass design system components
  - [ ] Set up development environment with mise and required tools

- [ ] **Data Layer Implementation** (AC: 3)
  - [ ] Create Patient SwiftData model with @Model macro and CloudKit compatibility
  - [ ] Implement compound uniqueness constraints for medical ID
  - [ ] Create Owner SwiftData model with proper relationships
  - [ ] Configure automatic timestamps and soft delete support
  - [ ] Set up many-to-one Patient-Owner and one-to-many relationships for appointments/medical records

- [ ] **Business Domain Models** (AC: 2)
  - [ ] Create Patient domain model with validation rules and business logic
  - [ ] Implement age calculation from birth date functionality
  - [ ] Create species-specific breed validation logic
  - [ ] Build medical ID generation algorithm
  - [ ] Implement business rules for future birth dates, weight ranges, and owner validation

- [ ] **Service Layer with Mocks** (AC: 5)
  - [ ] Define PatientService protocol with CRUD operations
  - [ ] Create MockPatientService with in-memory data store
  - [ ] Implement search functionality with error simulation
  - [ ] Add Mockable integration for testing
  - [ ] Set up validation logic and error handling in service layer

- [ ] **UI Layer with QuickForm** (AC: 1)
  - [ ] Create PatientFormViewModel using QuickForm with reactive field relationships
  - [ ] Build patient creation form using Form {} wrapper with QuickForm components
  - [ ] Implement species FormPickerField with breed filtering based on selection
  - [ ] Add form validation with inline error display using QuickForm validation
  - [ ] Create save/cancel actions with loading states and success confirmation

- [ ] **Sample Data Population** (AC: 6)
  - [ ] Create sample data generator with 20+ diverse patient records
  - [ ] Include varied species (dogs, cats, exotic pets) with realistic names
  - [ ] Generate corresponding owner records with varied demographics
  - [ ] Add realistic medical histories and age ranges
  - [ ] Implement data seeding mechanism for development/testing

- [ ] **Feature Flag Implementation** (AC: 8)
  - [ ] Set up `patient_management_v1` feature flag using iOS 26 Configuration framework
  - [ ] Implement feature visibility controls
  - [ ] Add mock vs. real data toggle functionality
  - [ ] Configure progressive rollout and A/B testing capabilities

- [ ] **Testing Implementation** (AC: 7)
  - [ ] Write unit tests for Patient validation logic using Swift Testing framework
  - [ ] Test age calculation accuracy and medical ID uniqueness with Swift Testing
  - [ ] Create integration tests for SwiftData persistence and CloudKit sync simulation
  - [ ] Build UI tests using XCTest and ViewInspector with accessibility identifiers for form flows
  - [ ] Test validation error display and success path verification with XCTest

## Dev Notes

### Previous Story Insights
This is the first story in the project, establishing the foundational patterns for the entire application.

### Data Models
**Patient Entity** [Source: architecture/04-data-models.md#patient-entity]:
```swift
@Model
final class Patient {
    @Attribute(.unique) var patientID: UUID
    var name: String
    var species: AnimalSpecies
    var breed: String?
    var dateOfBirth: Date?
    var gender: AnimalGender?
    var color: String?
    var microchipNumber: String?
    var medicalHistory: MedicalHistory
    var caseComplexity: CaseComplexityProfile
    var isActive: Bool
    var createdAt: Date
    var updatedAt: Date
    
    @Relationship(inverse: \Owner.patients) var owner: Owner?
    @Relationship(deleteRule: .cascade) var appointments: [Appointment] = []
    @Relationship(deleteRule: .cascade) var assessments: [CaseAssessment] = []
    @Relationship(deleteRule: .cascade) var medicalDocuments: [MedicalDocument] = []
}
```

**Owner Entity** [Source: architecture/04-data-models.md#owner-entity]:
```swift
@Model
final class Owner {
    @Attribute(.unique) var ownerID: UUID
    var firstName: String
    var lastName: String
    var email: String
    var phoneNumber: String
    var address: Address
    var emergencyContact: EmergencyContact?
    var preferredCommunication: CommunicationPreference
    var isActive: Bool
    var createdAt: Date
    var updatedAt: Date
    
    @Relationship(deleteRule: .cascade) var patients: [Patient] = []
    @Attribute(.unique) var emailKey: String { email.lowercased() }
}
```

### API Specifications
**Service Protocol** [Source: architecture/04-data-models.md#mock-service-example]:
```swift
@Mockable
protocol PatientService {
    func create(_ patient: Patient) async throws -> Patient
    func update(_ patient: Patient) async throws -> Patient
    func delete(_ patient: Patient) async throws
    func search(query: String) async throws -> [Patient]
    func fetch(limit: Int, offset: Int) async throws -> [Patient]
}
```

### Component Specifications
**QuickForm Integration** [Source: architecture/02-tech-stack.md#quickform-usage]:
```swift
@QuickForm(PatientComponents.self)
final class PatientFormViewModel: Validatable {
    @PropertyEditor(keyPath: \PatientComponents.name)
    var name = FormFieldViewModel(
        type: String.self,
        title: "Patient Name",
        validation: .combined(.notEmpty, .minLength(2), .maxLength(50))
    )
    
    @PropertyEditor(keyPath: \PatientComponents.species)
    var species = FormPickerFieldViewModel(
        type: Species.self,
        allValues: Species.allCases,
        title: "Species"
    )
    
    @PropertyEditor(keyPath: \PatientComponents.weight)
    var weight = FormFieldViewModel(
        type: UnitMass.self,
        title: "Weight",
        validation: .optional(.range(min: 0.1, max: 200.0))
    )
    
    @PropertyEditor(keyPath: \PatientComponents.breed)
    var breed = FormPickerFieldViewModel(
        type: String.self,
        allValues: [],
        title: "Breed"
    )
    
    @PropertyEditor(keyPath: \PatientComponents.dateOfBirth)
    var dateOfBirth = FormFieldViewModel(
        type: Date.self,
        title: "Date of Birth",
        validation: .required(.pastDate)
    )
    
    @PropertyEditor(keyPath: \PatientComponents.microchipNumber)
    var microchipNumber = FormFieldViewModel(
        type: String.self,
        title: "Microchip Number",
        validation: .optional(.pattern(#"^\d{15}$"#))
    )
    
    @PropertyEditor(keyPath: \PatientComponents.notes)
    var notes = FormFieldViewModel(
        type: String.self,
        title: "Notes",
        validation: .optional(.maxLength(500))
    )
    
    @PostInit
    func configure() {
        species.onValueChanged { [weak self] newSpecies in
            self?.updateBreedOptions(for: newSpecies)
        }
    }
}
```

**Form UI Implementation**:
```swift
struct PatientFormView: View {
    @State private var viewModel = PatientFormViewModel()
    
    var body: some View {
        Form {
            Section("Patient Information") {
                FormField(viewModel.name)
                    .accessibilityIdentifier("patient_name_field")
                
                FormPickerField(viewModel.species)
                    .accessibilityIdentifier("patient_species_picker")
                
                FormPickerField(viewModel.breed)
                    .accessibilityIdentifier("patient_breed_picker")
                
                FormDateField(viewModel.dateOfBirth)
                    .accessibilityIdentifier("patient_birth_date_picker")
                
                FormValueUnitField(viewModel.weight)
                    .accessibilityIdentifier("patient_weight_field")
                
                FormField(viewModel.microchipNumber)
                    .accessibilityIdentifier("patient_microchip_field")
                
                FormTextEditor(viewModel.notes)
                    .accessibilityIdentifier("patient_notes_editor")
            }
            
            Section("Actions") {
                Button("Save Patient") {
                    Task { await savePatient() }
                }
                .accessibilityIdentifier("save_patient_button")
                .disabled(!viewModel.isValid)
                
                Button("Cancel") {
                    dismiss()
                }
                .accessibilityIdentifier("cancel_patient_button")
            }
        }
        .navigationTitle("New Patient")
    }
}
```

### File Locations
**Module Structure** [Source: architecture/01-modular-design.md#standard-module-layout]:
- Features/PatientRecords/Domain/Models/Patient.swift
- Features/PatientRecords/Application/UseCases/CreatePatientUseCase.swift
- Features/PatientRecords/Infrastructure/Persistence/SwiftDataPatientRepository.swift
- Features/PatientRecords/Presentation/ViewModels/PatientFormViewModel.swift
- Features/PatientRecords/Presentation/Views/PatientFormView.swift
- Features/PatientRecords/Public/PatientModuleInterface.swift

**Project Root Structure**:
- App/Sources/ - Main iOS application using SwiftUI + MVVM
- Modules/SwiftUIRouting/ - Custom navigation framework
- Infrastructure/Persistence/ - DataStore implementations
- Infrastructure/EventBus/ - Inter-module communication

### Testing Requirements
**Testing Frameworks**:
- Swift Testing framework for unit tests and integration tests
- XCTest with ViewInspector for UI testing
- Mockable for protocol-based service mocking

**Testing Strategy** [Source: architecture/09-testing-strategy.md#swift-testing-framework-integration]:
- Use Swift Testing framework with @Suite and @Test attributes for business logic
- Use #expect() assertions for clear test validation
- Use XCTest with ViewInspector for SwiftUI component testing with accessibility identifiers
- Create comprehensive unit tests for validation logic and business rules
- Mock services using Mockable protocol-based testing

**Accessibility Testing** [Source: architecture/10-coding-standards.md#accessibility-integration-rule]:
- All components must include accessibilityIdentifier for testing
- Format: "component_type_identifier" (e.g., "patient_name_field")
- Implement accessibilityLabel for VoiceOver descriptions
- Support Dynamic Type and iOS 26 Accessibility Reader compatibility

### Technical Constraints
**Swift 6.2+ Requirements** [Source: architecture/10-coding-standards.md#structured-concurrency-rule]:
- Use structured concurrency patterns with TaskGroup for parallel operations
- All async operations must use async/await patterns
- Implement @Observable instead of ObservableObject for state management

**CloudKit Integration** [Source: architecture/04-data-models.md#cloudkit-integration]:
- Configure SwiftData with CloudKit synchronization
- Use custom DataStore protocol for HIPAA compliance
- Implement practice-specific data isolation through CloudKit zones

### Performance Considerations
**SwiftData Optimization** [Source: architecture/04-data-models.md#performance-optimizations]:
- Use compound constraints to prevent data conflicts
- Implement efficient relationship queries with predicates
- Configure proper indexing for search functionality

## Testing

### Test Location
All tests should be located in the Tests/ directory following the modular structure:
- Tests/UnitTests/PatientRecordsTests/ (Swift Testing)
- Tests/IntegrationTests/PatientModuleIntegrationTests.swift (Swift Testing)
- Tests/SwiftUITests/PatientFormUITests.swift (XCTest + ViewInspector)

### Testing Standards
**Unit/Integration Testing**: Swift Testing with @Suite and @Test attributes [Source: architecture/09-testing-strategy.md]
**UI Testing**: XCTest with ViewInspector for SwiftUI component testing
**Assertions**: Use #expect() for Swift Testing, XCTAssert for XCTest
**Mocking**: Mockable protocol-based service mocking

### Testing Patterns
**Unit Testing Example** [Source: architecture/09-testing-strategy.md#swift-testing-framework-integration]:
```swift
@Suite("Patient Validation Tests")
struct PatientValidationTests {
    @Test("Given valid patient data When creating patient Then validation succeeds")
    func testValidPatientCreation() async throws {
        let patient = Patient(name: "Max", species: .dog, owner: createTestOwner())
        let result = patient.validate()
        #expect(result.isValid)
    }
}
```

**UI Testing with XCTest and ViewInspector**:
```swift
import XCTest
import ViewInspector

final class PatientFormUITests: XCTestCase {
    func testPatientFormAccessibility() throws {
        let form = PatientFormView()
        let nameField = try form.inspect().find(
            viewWithAccessibilityIdentifier: "patient_name_field"
        )
        XCTAssertNotNil(nameField, "Name field should be accessible")
    }
    
    func testFormValidationDisplay() throws {
        let form = PatientFormView()
        let saveButton = try form.inspect().find(
            viewWithAccessibilityIdentifier: "save_patient_button"
        )
        XCTAssertTrue(try saveButton.button().isDisabled(), "Save button should be disabled with empty form")
    }
    
    func testWeightFieldWithUnits() throws {
        let form = PatientFormView()
        let weightField = try form.inspect().find(
            viewWithAccessibilityIdentifier: "patient_weight_field"
        )
        XCTAssertNotNil(weightField, "Weight field with units should be accessible")
    }
}
```

### Specific Testing Requirements
- Test patient validation logic including future birth date prevention
- Verify age calculation accuracy with edge cases
- Test medical ID uniqueness and generation algorithm
- Validate species-breed relationship filtering
- Test QuickForm reactive field relationships including weight unit handling
- Verify CloudKit sync simulation with mock data
- Test accessibility compliance with VoiceOver and Dynamic Type

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-22 | 1.0 | Initial story creation with comprehensive technical context | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled during development*

### Debug Log References
*To be filled during development*

### Completion Notes List
*To be filled during development*

### File List
*To be filled during development*

## QA Results

*This section will be populated by the QA Agent after story completion*