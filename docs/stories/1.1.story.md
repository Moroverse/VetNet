# Story 1.1: Patient Creation & Profile Management

## Story Information

**Epic**: 1 - Patient Management Foundation  
**Story Number**: 1.1  
**Title**: Patient Creation & Profile Management  
**Status**: Draft  
**Feature Flag**: `patient_management_v1`

## Story Statement

**As a** veterinary practice staff member,  
**I want to** create and manage patient profiles with essential information,  
**So that** I can maintain accurate patient records for scheduling and medical care.

## Acceptance Criteria

### 1. UI Layer
- Patient creation form with fields:
  - Name (required)
  - Species (required, dropdown)
  - Breed (required, filtered by species)
  - Date of birth (required, date picker)
  - Weight (optional, with units)
  - Owner information (required)
  - Medical ID (auto-generated)
  - Microchip number (optional)
  - Notes (optional, multiline)
- Form validation with inline errors
- Save/Cancel actions
- Loading states during save
- Success confirmation

### 2. Business Layer
- Patient domain model with:
  - Validation rules for all fields
  - Age calculation from birth date
  - Species-specific breed validation
  - Medical ID generation algorithm
  - Data transformation for persistence
- Business rules enforcement:
  - Future birth dates not allowed
  - Weight within species ranges
  - Owner relationship validation

### 3. Data Layer
- SwiftData Patient entity with:
  - CloudKit synchronization
  - Compound uniqueness constraints
  - Automatic timestamps
  - Soft delete support
- Relationships:
  - Owner (many-to-one)
  - Appointments (one-to-many)
  - Medical records (one-to-many)

### 4. Infrastructure
- Complete iOS project setup:
  - Swift 6.2+ configuration
  - Factory DI container setup
  - SwiftUIRouting integration
  - Liquid Glass design system
- Development environment:
  - Tuist configuration
  - Git repository setup
  - CI/CD pipeline foundation

### 5. Mock Services
- In-memory patient service with:
  - CRUD operations
  - Search functionality
  - Validation logic
  - Error simulation
- Service protocol definition
- Mockable integration

### 6. Sample Data
- Pre-populated database with 20+ patients:
  - Dogs: Labrador (Max, Bella), German Shepherd (Rex, Luna), Golden Retriever (Charlie, Daisy)
  - Cats: Persian (Whiskers, Mittens), Maine Coon (Oliver, Sophie), Siamese (Leo, Cleo)
  - Exotic: Rabbit (Bunny), Parrot (Polly), Bearded Dragon (Spike), Guinea Pig (Patches)
- Varied owner demographics
- Realistic medical histories
- Different age ranges

### 7. Testing
- Unit tests:
  - Patient validation logic
  - Age calculation accuracy
  - Medical ID uniqueness
- Integration tests:
  - Data persistence verification
  - CloudKit sync simulation
- UI tests:
  - Form completion flow
  - Validation error display
  - Success path verification

### 8. Feature Flag
- `patient_management_v1` controls:
  - Feature visibility
  - Mock vs. real data toggle
  - Progressive rollout
  - A/B testing capability

## Dev Notes

### Previous Story Insights
- No previous stories exist (this is the first story of the project)
- This story establishes the foundational patterns for all subsequent features

### Data Models

**Patient Entity** [Source: architecture/04-data-models.md#Patient Entity]:
```swift
@Model
final class Patient {
    @Attribute(.unique) var patientID: UUID
    var name: String
    var species: AnimalSpecies
    var breed: String?
    var dateOfBirth: Date?
    var gender: AnimalGender?
    var color: String?
    var microchipNumber: String?
    var medicalHistory: MedicalHistory
    var caseComplexity: CaseComplexityProfile
    var isActive: Bool
    var createdAt: Date
    var updatedAt: Date
    
    @Relationship(inverse: \Owner.patients) var owner: Owner?
    @Relationship(deleteRule: .cascade) var appointments: [Appointment] = []
    @Relationship(deleteRule: .cascade) var assessments: [CaseAssessment] = []
    @Relationship(deleteRule: .cascade) var medicalDocuments: [MedicalDocument] = []
}
```

**Owner Entity** [Source: architecture/04-data-models.md#Owner Entity]:
```swift
@Model
final class Owner {
    @Attribute(.unique) var ownerID: UUID
    var firstName: String
    var lastName: String
    var email: String
    var phoneNumber: String
    var address: Address
    var emergencyContact: EmergencyContact?
    var preferredCommunication: CommunicationPreference
    var isActive: Bool
    var createdAt: Date
    var updatedAt: Date
    
    @Relationship(deleteRule: .cascade) var patients: [Patient] = []
    
    // Compound constraint preventing duplicate emails
    @Attribute(.unique) var emailKey: String { email.lowercased() }
}
```

**Supporting Value Objects** [Source: architecture/04-data-models.md#Supporting Value Objects]:
```swift
struct MedicalHistory: Codable {
    var conditions: [MedicalCondition]
    var medications: [Medication]
    var allergies: [Allergy]
    var vaccinations: [Vaccination]
    var surgicalHistory: [Surgery]
}

struct CaseComplexityProfile: Codable {
    var baseComplexity: Float
    var speciesModifier: Float
    var ageModifier: Float
    var medicalHistoryModifier: Float
    var lastUpdated: Date
    
    var overallComplexity: Float {
        return baseComplexity + speciesModifier + ageModifier + medicalHistoryModifier
    }
}
```

### API Specifications

**Patient Module Public Interface** [Source: architecture/04-data-models.md#Module Public Interface DTOs]:
```swift
public protocol PatientModuleInterface {
    func createPatient(_ request: CreatePatientRequest) async throws -> PatientDTO
    func updatePatient(_ request: UpdatePatientRequest) async throws -> PatientDTO
    func getPatient(_ id: UUID) async throws -> PatientDTO
    func searchPatients(criteria: SearchCriteria) async -> [PatientSummary]
}

public struct PatientDTO: Codable {
    public let id: UUID
    public let name: String
    public let species: String
    public let breed: String?
    public let ownerId: UUID
    public let lastVisit: Date?
}

public struct CreatePatientRequest: Codable {
    public let name: String
    public let species: String
    public let breed: String?
    public let dateOfBirth: Date?
    public let ownerInformation: OwnerInformation
    public let microchipNumber: String?
    public let notes: String?
}
```

### Component Specifications

**Patient Creation Form Components** [Source: architecture/05-components.md#Shared UI Components]:
```swift
// Liquid Glass form container
public struct GlassPatientForm<Content: View>: View {
    let content: Content
    
    public var body: some View {
        GlassContainer(style: VeterinaryGlassStyles.triageForm) {
            content
        }
        .accessibilityIdentifier("patient_creation_form")
    }
}

// Accessible form field components
public struct AccessibleFormField: View {
    let label: String
    let placeholder: String
    let accessibilityId: String
    
    public var body: some View {
        TextField(label, text: $value)
            .accessibilityLabel(label)
            .accessibilityIdentifier(accessibilityId)
            .textFieldStyle(.roundedBorder)
    }
}
```

### File Locations

**Module Structure** [Source: architecture/01-modular-design.md#Standard Module Layout]:
```
Features/PatientRecords/
├── Package.swift
├── Sources/
│   ├── Domain/
│   │   ├── Models/
│   │   │   ├── Patient.swift          # Internal domain model
│   │   │   ├── Owner.swift
│   │   │   └── ValidationRules.swift
│   │   ├── Services/
│   │   │   └── PatientValidationService.swift
│   │   └── Repositories/
│   │       └── PatientRepository.swift  # Protocol only
│   ├── Application/
│   │   ├── UseCases/
│   │   │   ├── CreatePatientUseCase.swift
│   │   │   └── ValidatePatientUseCase.swift
│   │   └── Services/
│   │       └── MedicalIDGenerationService.swift
│   ├── Infrastructure/
│   │   ├── Persistence/
│   │   │   └── SwiftDataPatientRepository.swift
│   │   └── External/
│   │       └── CloudKitSyncService.swift
│   ├── Presentation/
│   │   ├── ViewModels/
│   │   │   └── PatientCreationViewModel.swift
│   │   └── Views/
│   │       ├── PatientCreationForm.swift
│   │       └── PatientDetailsView.swift
│   └── Public/
│       ├── PatientModuleInterface.swift
│       ├── DTOs/
│       │   └── PatientDTO.swift
│       └── Events/
│           └── PatientCreatedEvent.swift
```

**Main App Integration** [Source: architecture/01-modular-design.md#Application Layer]:
```
App/Sources/
├── CompositionRoot/
│   └── AppContainer.swift         # DI container setup
├── Coordinators/
│   └── AppCoordinator.swift       # Navigation coordination
└── Views/
    └── ContentView.swift          # Root view
```

### Testing Requirements

**Swift Testing Framework** [Source: architecture/09-testing-strategy.md#Swift Testing Framework Integration]:
```swift
@Suite("Patient Creation Tests")
struct PatientCreationTests {
    @Test("Patient validation rules enforcement")
    func testPatientValidation() async throws {
        let validationService = PatientValidationService()
        
        // Test required fields
        #expect(
            throws: ValidationError.requiredField,
            performing: {
                try validationService.validate(Patient(name: "", species: .dog))
            }
        )
        
        // Test future birth date validation
        let futureDate = Date().addingTimeInterval(86400) // Tomorrow
        #expect(
            throws: ValidationError.invalidBirthDate,
            performing: {
                try validationService.validate(Patient(name: "Test", species: .dog, dateOfBirth: futureDate))
            }
        )
    }
}
```

**ViewInspector UI Testing** [Source: architecture/09-testing-strategy.md#ViewInspector SwiftUI Testing]:
```swift
@Test("Patient creation form accessibility")
func testPatientFormAccessibility() throws {
    let form = PatientCreationForm()
    
    // Use accessibility identifiers for reliable testing
    let nameField = try form.inspect().find(
        viewWithAccessibilityIdentifier: "patient_name_field"
    )
    let speciesDropdown = try form.inspect().find(
        viewWithAccessibilityIdentifier: "patient_species_dropdown"
    )
    let submitButton = try form.inspect().find(
        viewWithAccessibilityIdentifier: "patient_submit_button"
    )
    
    #expect(nameField != nil, "Name field should be present")
    #expect(speciesDropdown != nil, "Species dropdown should be present")
    #expect(submitButton != nil, "Submit button should be present")
}
```

**Mockable Service Testing** [Source: architecture/09-testing-strategy.md#Mockable Service Testing]:
```swift
@Mockable
protocol PatientService {
    func createPatient(_ patient: CreatePatientRequest) async throws -> PatientDTO
    func updatePatient(_ id: UUID, request: UpdatePatientRequest) async throws -> PatientDTO
    func getPatient(_ id: UUID) async throws -> PatientDTO
}
```

### Technical Constraints

**iOS 26 Requirements** [Source: architecture/02-tech-stack.md#Version Requirements]:
- **Target iOS**: 26.0+ for Liquid Glass and performance optimizations
- **Minimum iOS**: 17.0+ for SwiftUIRouting module compatibility
- **Swift**: 6.2+ with structured concurrency patterns
- **Xcode**: 26.0+ for iOS 26 Liquid Glass compilation

**SwiftData Constraints** [Source: architecture/10-coding-standards.md#SwiftData + CloudKit Integration Rule]:
- All data models must use @Model macro with proper relationships
- Compound uniqueness constraints (@Attribute(.unique)) to prevent conflicts
- CloudKit-compatible types only

**Accessibility Requirements** [Source: architecture/10-coding-standards.md#Accessibility Integration Rule]:
- All custom UI components must integrate iOS 26 accessibility features
- VoiceOver descriptions and Dynamic Type support required
- Accessibility Reader compatibility for medical terminology

**HIPAA Compliance** [Source: architecture/04-data-models.md#HIPAA Compliance Considerations]:
- All patient data encrypted at rest using CloudKit's encryption
- Additional application-level encryption for sensitive fields
- Audit trails for all data access and modifications
- Practice-level data isolation through CloudKit zones

## Tasks / Subtasks

### Task 1: Project Foundation Setup (AC: 4)
1. **Configure Tuist project structure**
   - Create Tuist Project.swift with iOS 26 target [Source: architecture/02-tech-stack.md#Project Management]
   - Configure Swift 6.2+ language settings
   - Set up bundle ID: com.moroverse.VetNet
   - Configure multi-platform targets (iPad, iPhone)

2. **Initialize SwiftUIRouting module**
   - Set up Modules/SwiftUIRouting/ package structure [Source: architecture/02-tech-stack.md#Custom Dependencies]
   - Implement basic Router protocol
   - Create navigation patterns for veterinary workflows

3. **Set up Factory DI container**
   - Configure Factory 2.3+ dependency injection [Source: architecture/02-tech-stack.md#Core Dependencies]
   - Register core services
   - Set up module interfaces

4. **Initialize git repository and CI foundation**
   - Set up git repository with proper .gitignore
   - Create basic GitHub Actions workflow for testing
   - Configure code quality checks

### Task 2: Patient Records Module Implementation (AC: 2, 3)
1. **Create module structure using Clean Architecture**
   - Set up Features/PatientRecords/ package [Source: architecture/01-modular-design.md#Standard Module Layout]
   - Implement Domain layer (models, services, repositories)
   - Implement Application layer (use cases, application services)
   - Implement Infrastructure layer (SwiftData repository)

2. **Implement Patient domain model**
   - Create Patient entity with @Model macro [Source: architecture/04-data-models.md#Patient Entity]
   - Implement MedicalHistory and CaseComplexityProfile value objects
   - Add validation rules and business logic methods
   - Implement age calculation and medical ID generation

3. **Implement Owner domain model**
   - Create Owner entity with proper relationships [Source: architecture/04-data-models.md#Owner Entity]
   - Add compound uniqueness constraints for email
   - Implement address and emergency contact structures

4. **Create SwiftData repository implementation**
   - Implement SwiftDataPatientRepository [Source: architecture/05-components.md#Persistence Layer]
   - Configure CloudKit synchronization
   - Set up compound constraints for data integrity
   - Implement soft delete support

### Task 3: UI Layer Implementation (AC: 1)
1. **Create patient creation form with Liquid Glass**
   - Implement PatientCreationForm using GlassContainer [Source: architecture/05-components.md#Liquid Glass Design System]
   - Add form fields with proper validation
   - Implement species-filtered breed dropdown
   - Add date picker for birth date

2. **Implement form validation and error handling**
   - Add inline validation with error messages
   - Implement real-time validation feedback
   - Create validation error display components

3. **Add loading states and success confirmation**
   - Implement loading indicators during save operations
   - Create success confirmation dialog
   - Add proper error handling for failed operations

4. **Ensure accessibility compliance**
   - Add accessibility identifiers for all form elements [Source: architecture/10-coding-standards.md#Accessibility Integration Rule]
   - Implement VoiceOver support with descriptive labels
   - Add Dynamic Type support for all text

### Task 4: Mock Services Implementation (AC: 5)
1. **Create PatientService protocol**
   - Define service interface with CRUD operations [Source: architecture/09-testing-strategy.md#Mockable Service Testing]
   - Add @Mockable annotation for testing
   - Implement search and validation methods

2. **Implement in-memory service**
   - Create MockPatientService with in-memory storage
   - Add CRUD operations with proper error simulation
   - Implement search functionality with filtering
   - Add validation logic matching domain rules

3. **Set up Mockable integration**
   - Configure Mockable for protocol-based mocking
   - Create test mocks for isolated unit testing
   - Set up mock configurations for different test scenarios

### Task 5: Sample Data Population (AC: 6)
1. **Create sample data generator**
   - Implement SampleDataGenerator service
   - Create 20+ diverse patient records as specified
   - Include varied owner demographics and medical histories

2. **Populate database on first launch**
   - Create database seeding logic
   - Ensure sample data respects all validation rules
   - Add different age ranges and species variety

3. **Configure feature flag integration**
   - Set up patient_management_v1 feature flag
   - Control sample data vs. real data toggle
   - Implement progressive rollout capabilities

### Task 6: Comprehensive Testing Implementation (AC: 7)
1. **Unit tests for domain logic**
   - Test patient validation rules [Source: architecture/09-testing-strategy.md#Swift Testing Framework Integration]
   - Test age calculation accuracy
   - Test medical ID uniqueness algorithm
   - Test business rule enforcement

2. **Integration tests for persistence**
   - Test SwiftData persistence operations
   - Test CloudKit sync simulation
   - Test relationship integrity and constraints

3. **UI tests with ViewInspector**
   - Test form completion flow [Source: architecture/09-testing-strategy.md#ViewInspector SwiftUI Testing]
   - Test validation error display
   - Test accessibility identifier consistency
   - Test success path verification

4. **Performance and accessibility tests**
   - Test form responsiveness with large datasets
   - Test VoiceOver navigation
   - Test Dynamic Type scaling
   - Test memory usage during patient creation

### Task 7: Feature Flag and Analytics Integration (AC: 8)
1. **Implement feature flag system**
   - Set up iOS 26 Configuration framework [Source: architecture/02-tech-stack.md#Configuration Management]
   - Create patient_management_v1 flag controls
   - Implement A/B testing capability

2. **Add analytics tracking**
   - Track patient creation metrics
   - Monitor form completion rates
   - Log validation error patterns
   - Track feature usage statistics

3. **Configure progressive rollout**
   - Set up staged feature deployment
   - Implement rollback capabilities
   - Add monitoring for feature health

## Project Structure Notes

The story aligns with the modular architecture defined in the unified project structure. The Patient Records module follows Clean Architecture principles with clear layer separation. All file locations match the documented module structure patterns.

**Infrastructure Integration**: The story properly integrates with shared infrastructure services (persistence, event bus, dependency injection) as defined in the architecture documents.

**Cross-Module Preparation**: While this is the first story, the implementation establishes patterns that will be reused in subsequent modules (Triage, Scheduling, Specialist Management).

**No Conflicts Identified**: All requirements align with the established architecture patterns and technical constraints.

## Definition of Done

Staff can create new patient records, view patient details, and interact with realistic sample data immediately upon app launch. The implementation establishes the foundational patterns for the entire application while delivering immediate value to veterinary practice users.