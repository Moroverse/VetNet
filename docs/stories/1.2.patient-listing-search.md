# Story 1.2: Patient Listing & Search

## Status
Draft

## Story
**As a** veterinary practice staff member,  
**I want to** quickly find and view patient information,  
**so that** I can access patient records during consultations and scheduling.

## Acceptance Criteria

1. **UI Layer**
   - Patient list view with:
     - Searchable list interface
     - Search bar with real-time results
     - Filter options (species, breed, active/inactive)
     - Sort options (name, last visit, age)
     - Pull-to-refresh functionality
   - List item display:
     - Patient photo placeholder
     - Name and species
     - Owner name
     - Age
     - Last visit date
   - Liquid Glass visual effects:
     - Glass list background
     - Hover effects on iPad
     - Selection animations

2. **Business Layer**
   - Search algorithms:
     - Fuzzy matching for names
     - Owner name search
     - Medical ID lookup
     - Phonetic matching
   - Filtering logic:
     - Multi-criteria filtering
     - Saved filter sets
     - Quick filter presets
   - Sorting implementation:
     - Multiple sort keys
     - Stable sort order
     - Performance optimization

3. **Data Layer**
   - Optimized queries:
     - SwiftData #Index usage
     - Lazy loading
     - Pagination support
     - Cache management
   - Search indexing:
     - Full-text search
     - Denormalized search fields
     - Background indexing

4. **Performance**
   - Search results display:
     - < 500ms for 10,000 patients
     - Incremental loading
     - Smooth scrolling
     - Memory efficiency
   - Optimization techniques:
     - Debounced search
     - Result caching
     - Virtual scrolling

5. **Testing**
   - Performance tests:
     - Large dataset handling
     - Search speed benchmarks
     - Memory usage profiling
   - Accessibility tests:
     - VoiceOver navigation
     - Keyboard navigation
     - Dynamic Type support
   - UI tests:
     - Search workflows
     - Filter combinations
     - Sort verification

6. **Feature Flag**
   - `patient_search_v1` controls:
     - Search functionality
     - Advanced filters
     - Performance features
     - UI enhancements

## Tasks / Subtasks

- [ ] **Task 1: Create Patient List UI Components** (AC: 1)
  - [ ] Create `PatientListView` with Liquid Glass design using `GlassEffectContainer`
  - [ ] Implement `PatientRowView` with photo placeholder, name, species, owner, age, last visit
  - [ ] Add search bar with real-time text binding
  - [ ] Create filter sidebar with species/breed/status options
  - [ ] Add sort selector with name/last visit/age options
  - [ ] Implement pull-to-refresh functionality
  - [ ] Add accessibility identifiers: `patient_list_view`, `search_bar`, `filter_button`
  - [ ] Include iPad hover effects and selection animations

- [ ] **Task 2: Build Search and Filter Business Logic** (AC: 2)
  - [ ] Create `PatientSearchService` protocol and implementation
  - [ ] Implement fuzzy name matching using `NSString` comparison methods
  - [ ] Add owner name search capability
  - [ ] Build medical ID lookup functionality
  - [ ] Create phonetic matching using `NSString.localizedStandardContains`
  - [ ] Implement multi-criteria filtering with `NSPredicate` combinations
  - [ ] Add saved filter sets with persistent storage
  - [ ] Create quick filter presets (active patients, recent visits)

- [ ] **Task 3: Optimize Data Layer Queries** (AC: 3)
  - [ ] Add `#Index` annotations to `PatientEntity` for search fields
  - [ ] Implement lazy loading with `FetchDescriptor` and pagination
  - [ ] Create `PatientSearchRepository` extending base repository
  - [ ] Add full-text search using SwiftData predicates
  - [ ] Implement denormalized search fields for performance
  - [ ] Add background indexing for search optimization
  - [ ] Create result caching mechanism

- [ ] **Task 4: Implement Performance Optimizations** (AC: 4)
  - [ ] Add debounced search with 300ms delay using `@State` and `Timer`
  - [ ] Implement incremental loading with `LazyVStack`
  - [ ] Create virtual scrolling for large datasets
  - [ ] Add memory management for list items
  - [ ] Optimize scroll performance with `.scrollTargetLayout()`
  - [ ] Implement result caching with TTL expiration
  - [ ] Add performance monitoring and benchmarks

- [ ] **Task 5: Create List View Models and State Management** (AC: 1, 2)
  - [ ] Create `PatientListViewModel` with `@Observable` for reactive updates
  - [ ] Implement `SearchState` enum (idle, searching, results, error, empty)
  - [ ] Add `FilterState` with active filter tracking
  - [ ] Create `SortState` with current sort criteria
  - [ ] Implement search result binding with SwiftData queries
  - [ ] Add error handling for failed searches
  - [ ] Include loading states for long operations

- [ ] **Task 6: Implement Comprehensive Testing** (AC: 5)
  - [ ] Create performance tests for large datasets (1000+ patients)
  - [ ] Add search speed benchmarks with XCTMetric
  - [ ] Test memory usage with Instruments integration
  - [ ] Implement VoiceOver navigation tests
  - [ ] Add keyboard navigation testing
  - [ ] Test Dynamic Type support across size categories
  - [ ] Create UI workflow tests: search, filter, sort combinations
  - [ ] Add edge case testing: empty results, network failures

## Dev Notes

### Architecture Context
This story builds upon Story 1.1's foundation to provide comprehensive patient search and listing capabilities. All technical details follow the established VetNet architecture patterns for performance and user experience.

### SwiftData Query Optimization
**Index Configuration**: `Infrastructure/Persistence/Entities/PatientEntity.swift`
- Add `#Index` annotations for frequently searched fields
- Composite indexes for multi-field searches: `#Index([\.name, \.species])`
- Optimize CloudKit sync performance with strategic indexing
[Source: docs/architecture/04-data-models.md#query-optimization]

### Search Service Architecture
**Location**: `Features/PatientRecords/Application/Services/PatientSearchService.swift`
```swift
@Mockable
protocol PatientSearchService {
    func search(query: String, filters: SearchFilters) async throws -> [Patient]
    func quickSearch(query: String) async throws -> [Patient]
    func applyFilters(_ filters: SearchFilters) async throws -> [Patient]
    func getSavedFilters() async -> [SavedFilter]
}
```
- Debounced search implementation with Combine
- Result caching with configurable TTL
- Fuzzy matching using `NSString.localizedStandardContains`
[Source: docs/architecture/03-feature-modules.md#service-layer]

### UI Performance Patterns
**List Optimization**: `Features/PatientRecords/Presentation/Views/PatientListView.swift`
- `LazyVStack` for memory-efficient rendering
- Virtual scrolling with `.scrollTargetLayout()`
- Incremental loading using `@State` pagination tracking
- Result caching to prevent redundant queries
[Source: docs/architecture/05-components.md#list-performance]

### Liquid Glass List Design
**Visual Effects**: 
- `GlassEffectContainer` wrapping the entire list
- Individual row glass effects: `.glassEffect(.thin, in: .rect(cornerRadius: 8))`
- Selection morphing with `glassEffectID("patient_row_\(patient.id)")`
- iPad hover states using `.hoverEffect()` modifier
[Source: docs/architecture/10-coding-standards.md#liquid-glass-lists]

### Search Algorithm Implementation
**Fuzzy Matching Strategy**:
- Primary: `NSString.localizedStandardContains` for locale-aware matching
- Secondary: Levenshtein distance for typo tolerance
- Phonetic matching using `NSString.localizedStandardRange`
- Owner name inclusion in search results
- Medical ID exact matching with prefix support
[Source: docs/architecture/06-workflows.md#search-patterns]

### Filter and Sort State Management
**State Structure**: 
```swift
@Observable
final class PatientListViewModel {
    var searchQuery: String = ""
    var searchState: SearchState = .idle
    var activeFilters: SearchFilters = .init()
    var sortCriteria: SortCriteria = .name
    var patients: [Patient] = []
}

enum SearchState: Equatable {
    case idle, searching, results(count: Int), error(String), empty
}
```
[Source: docs/architecture/05-components.md#state-management]

### Performance Requirements and Monitoring
**Benchmarks**:
- Search response time: <500ms for 10,000 patients
- Memory usage: <50MB for 1000 visible items
- Scroll performance: 60fps with large datasets
- Network efficiency: Minimal CloudKit queries during search
[Source: docs/architecture/08-security-performance.md#performance-targets]

### Data Repository Extensions
**Search Repository**: `Infrastructure/Repositories/SwiftDataPatientSearchRepository.swift`
- Extends `SwiftDataPatientRepository` with search-specific methods
- Implements full-text search using `#Predicate` with regex patterns
- Batch loading with configurable page sizes
- Search result ranking based on relevance scores
[Source: docs/architecture/03-feature-modules.md#repository-extensions]

### Accessibility Implementation
**Required Accessibility Features**:
- VoiceOver navigation with descriptive labels
- Search results announcement: "Found X patients"
- Filter state announcements: "Filtered by: Dogs, Active"
- Dynamic Type support for all text elements
- Keyboard navigation with focus management
- Reduced motion compliance for animations
[Source: docs/architecture/10-coding-standards.md#accessibility-patterns]

### Saved Filters and Presets
**Persistence Strategy**: 
- User defaults for simple filter preferences
- SwiftData entities for complex saved searches
- Quick filter presets: "Recent Patients", "Active Only", "Dogs", "Cats"
- Filter sharing between devices via CloudKit
[Source: docs/architecture/04-data-models.md#user-preferences]

## Testing

### Testing Framework and Patterns
**Performance Testing**: XCTest with XCTMetric integration
**Search Testing**: Custom test datasets with known search patterns
**UI Testing**: ViewInspector with accessibility identifier validation
**Memory Testing**: Automated memory leak detection
[Source: docs/architecture/09-testing-strategy.md#performance-testing]

### Test File Structure
```
PatientRecordsTests/
├── Application/
│   └── PatientSearchServiceTests.swift
├── Infrastructure/
│   └── PatientSearchRepositoryTests.swift
├── Presentation/
│   ├── PatientListViewTests.swift
│   └── PatientListViewModelTests.swift
└── Performance/
    ├── SearchPerformanceTests.swift
    └── ListScrollingPerformanceTests.swift
```

### Performance Test Requirements
```swift
@Test("Search performance benchmark")
func testSearchPerformance() throws {
    let options = XCTMeasureOptions()
    options.iterationCount = 10
    
    measure(metrics: [XCTClockMetric()], options: options) {
        // Search through 10,000 patients
        _ = searchService.search(query: "max", filters: .none)
    }
    
    // Assert < 500ms average
}
```

### Accessibility Testing Patterns
```swift
@Test("Patient list accessibility testing")  
func testPatientListAccessibility() throws {
    let listView = PatientListView()
    
    // Test VoiceOver navigation
    let searchBar = try listView.inspect().find(
        viewWithAccessibilityIdentifier: "search_bar"
    )
    
    #expect(try searchBar.textField().accessibilityLabel() == "Search patients")
    
    // Test Dynamic Type support
    listView.environment(\.sizeCategory, .accessibilityExtraExtraExtraLarge)
    #expect(try listView.inspect().find(text: "Patient Name").exists)
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-22 | 1.0 | Initial story creation from Epic 1.2 | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*This section will be populated by the QA Agent after story completion*