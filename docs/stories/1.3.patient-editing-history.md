# Story 1.3: Patient Profile Editing & History Tracking

## Status
Draft

## Story
**As a** veterinary practice staff member,  
**I want to** update patient information and track changes over time,  
**so that** patient records remain current and I can see the evolution of patient care.

## Acceptance Criteria

1. **UI Layer**
   - Patient edit form with:
     - Pre-filled current values
     - Field-level validation
     - Change indicators
     - Confirmation dialogs
     - Discard changes option
   - Audit trail display:
     - Change history list
     - User attribution
     - Timestamp display
     - Change details
     - Revert capabilities

2. **Business Layer**
   - Change tracking logic:
     - Field-level changes
     - Before/after values
     - User attribution
     - Timestamp recording
   - Validation rules:
     - Consistency checks
     - Business rule enforcement
     - Conflict detection
   - Update workflows:
     - Optimistic updates
     - Rollback support
     - Batch updates

3. **Data Layer**
   - Update operations:
     - Optimistic locking
     - Version tracking
     - Audit log storage
   - Change history:
     - Immutable audit records
     - Efficient storage
     - Query optimization

4. **Sync Layer**
   - Conflict resolution:
     - Last-write-wins default
     - Manual resolution UI
     - Merge strategies
   - Multi-device coordination:
     - Real-time updates
     - Conflict notifications
     - Sync status display

5. **Testing**
   - Concurrency tests:
     - Simultaneous edits
     - Conflict scenarios
     - Resolution verification
   - Data integrity tests:
     - Change tracking accuracy
     - Audit trail completeness
     - Rollback functionality
   - UI tests:
     - Edit workflows
     - Conflict resolution
     - History navigation

6. **Feature Flag**
   - `patient_editing_v1` enables:
     - Editing capabilities
     - Audit trail access
     - Conflict resolution
     - Advanced features

## Tasks / Subtasks

- [ ] **Task 1: Create Patient Edit UI Components** (AC: 1)
  - [ ] Create `PatientEditView` extending `PatientFormView` with pre-filled values
  - [ ] Add change indicator UI with modified field highlighting
  - [ ] Implement confirmation dialogs for destructive changes
  - [ ] Create "Discard Changes" functionality with unsaved changes detection
  - [ ] Add loading states for save/update operations
  - [ ] Include accessibility identifiers: `edit_patient_form`, `discard_changes_button`, `save_changes_button`
  - [ ] Apply Liquid Glass effects consistent with creation form

- [ ] **Task 2: Build Audit Trail UI Components** (AC: 1)
  - [ ] Create `PatientHistoryView` displaying chronological change list
  - [ ] Implement `ChangeHistoryRowView` with user, timestamp, and change details
  - [ ] Add expandable change details with before/after values
  - [ ] Create revert capability UI with confirmation prompts
  - [ ] Include filter options for change types and date ranges
  - [ ] Add accessibility support for history navigation
  - [ ] Implement Liquid Glass timeline design

- [ ] **Task 3: Implement Change Tracking Business Logic** (AC: 2)
  - [ ] Create `ChangeTrackingService` protocol and implementation
  - [ ] Build field-level change detection using property wrappers
  - [ ] Implement before/after value capture with JSON serialization
  - [ ] Add user attribution tracking with current user context
  - [ ] Create timestamp recording with timezone handling
  - [ ] Build business rule validation for update consistency
  - [ ] Add change conflict detection algorithms

- [ ] **Task 4: Design Audit Log Data Model** (AC: 3)
  - [ ] Create `PatientChangeLogEntity` SwiftData model
  - [ ] Add immutable audit record properties: changeId, patientId, fieldName, oldValue, newValue
  - [ ] Include metadata: userId, timestamp, changeType, deviceId
  - [ ] Implement efficient storage with compressed JSON values
  - [ ] Add query optimization with composite indexes
  - [ ] Create `ChangeLogRepository` with specialized queries
  - [ ] Ensure CloudKit synchronization for audit records

- [ ] **Task 5: Build Update Operations Infrastructure** (AC: 3)
  - [ ] Implement optimistic locking using version fields
  - [ ] Create version tracking with auto-increment on updates
  - [ ] Build batch update operations for multiple field changes
  - [ ] Add rollback support with change log reversal
  - [ ] Implement transactional updates with SwiftData
  - [ ] Create update conflict detection and resolution
  - [ ] Add retry mechanisms for failed updates

- [ ] **Task 6: Implement Multi-Device Sync and Conflict Resolution** (AC: 4)
  - [ ] Create `SyncConflictResolver` service for CloudKit conflicts
  - [ ] Implement last-write-wins strategy as default resolution
  - [ ] Build manual conflict resolution UI for complex cases
  - [ ] Add real-time update notifications using CloudKit push
  - [ ] Create sync status display with connection indicators
  - [ ] Implement merge strategies for non-conflicting changes
  - [ ] Add conflict notification system with user alerts

- [ ] **Task 7: Create Edit View Models and State Management** (AC: 1, 2)
  - [ ] Create `PatientEditViewModel` extending form view model
  - [ ] Implement `EditState` enum: viewing, editing, saving, conflict, error
  - [ ] Add unsaved changes tracking with dirty field indicators
  - [ ] Create change validation pipeline with business rules
  - [ ] Implement optimistic UI updates with rollback capability
  - [ ] Add edit session management with timeout handling
  - [ ] Build change batch processing for efficient updates

- [ ] **Task 8: Implement Comprehensive Testing** (AC: 5)
  - [ ] Create concurrency tests for simultaneous patient edits
  - [ ] Build conflict scenario testing with mock CloudKit conflicts
  - [ ] Test change tracking accuracy with edge cases
  - [ ] Add audit trail completeness verification
  - [ ] Implement rollback functionality testing
  - [ ] Create UI workflow tests for edit and history views
  - [ ] Add performance tests for large change histories

## Dev Notes

### Architecture Context
This story builds upon Stories 1.1 and 1.2 to provide complete patient lifecycle management with comprehensive audit trails and multi-device conflict resolution. The implementation follows established patterns while adding sophisticated change tracking capabilities.

### Change Tracking Data Model
**Audit Log Entity**: `Infrastructure/Persistence/Entities/PatientChangeLogEntity.swift`
```swift
@Model
final class PatientChangeLogEntity {
    @Attribute(.unique) let changeId: UUID
    let patientId: UUID
    let fieldName: String
    let oldValue: String? // JSON serialized
    let newValue: String? // JSON serialized
    let changeType: ChangeType // created, updated, deleted, reverted
    let userId: String
    let deviceId: String
    let timestamp: Date
    let version: Int
    
    @Relationship(deleteRule: .nullify)
    var patient: PatientEntity?
}
```
[Source: docs/architecture/04-data-models.md#audit-entities]

### Change Detection Implementation
**Property Wrapper Pattern**: `Features/PatientRecords/Domain/ChangeTracking/`
```swift
@propertyWrapper
struct Tracked<Value: Codable> {
    private var _value: Value
    private let fieldName: String
    private var hasChanged: Bool = false
    
    var wrappedValue: Value {
        get { _value }
        set { 
            if _value != newValue {
                hasChanged = true
            }
            _value = newValue 
        }
    }
    
    var projectedValue: ChangeTracker<Value> {
        ChangeTracker(oldValue: _value, hasChanged: hasChanged, fieldName: fieldName)
    }
}
```
[Source: docs/architecture/04-data-models.md#change-tracking-patterns]

### Optimistic Locking Strategy
**Version Control**: `Infrastructure/Repositories/SwiftDataPatientRepository.swift`
- Add `version: Int` field to `PatientEntity` with auto-increment on updates  
- Compare version on update operations to detect concurrent modifications
- Throw `ConcurrentModificationError` when version mismatch detected
- Implement retry logic with user conflict resolution prompts
[Source: docs/architecture/08-security-performance.md#concurrency-control]

### CloudKit Conflict Resolution
**Sync Service**: `Infrastructure/Services/PatientSyncService.swift`
```swift
@Mockable
protocol PatientSyncService {
    func resolveConflict(_ conflict: CKSyncConflict) async throws -> ConflictResolution
    func applyRemoteChanges(_ changes: [PatientChange]) async throws
    func publishLocalChanges(_ changes: [PatientChange]) async throws
    func handleMergeConflict(_ local: Patient, _ remote: Patient) async -> Patient
}
```
- Last-write-wins for simple field updates
- Manual resolution UI for complex conflicts
- Change log preservation during conflict resolution
[Source: docs/architecture/06-workflows.md#sync-patterns]

### Edit Form State Management
**State Architecture**: `Features/PatientRecords/Presentation/ViewModels/PatientEditViewModel.swift`
```swift
@Observable
final class PatientEditViewModel: PatientFormViewModel {
    var editState: EditState = .viewing
    var originalPatient: Patient
    var hasUnsavedChanges: Bool { /* dirty field detection */ }
    var changesSummary: [FieldChange] = []
    
    enum EditState: Equatable {
        case viewing, editing, validating, saving, conflict(ConflictData), error(String)
    }
}
```
[Source: docs/architecture/05-components.md#edit-state-management]

### Audit Trail UI Design
**History Timeline**: `Features/PatientRecords/Presentation/Views/PatientHistoryView.swift`
- Chronological list with expandable change details
- User avatars and attribution display
- Before/after value comparison UI
- Revert action with confirmation dialogs
- Filter by change type, date range, and user
- Liquid Glass timeline effects with morphing animations
[Source: docs/architecture/05-components.md#audit-ui-patterns]

### Business Rule Validation
**Update Consistency**: `Features/PatientRecords/Domain/Validation/UpdateValidator.swift`
- Validate field relationships during updates (species/breed consistency)
- Prevent invalid state transitions (weight reductions requiring justification)
- Enforce business logic constraints (vaccination schedules)
- Check referential integrity (owner relationships)
[Source: docs/architecture/04-data-models.md#business-rules]

### Performance Optimization
**Change Log Queries**: 
- Composite indexes: `#Index([\.patientId, \.timestamp])`
- Pagination for large change histories
- Lazy loading of change details
- Background change log maintenance
- Compressed JSON storage for large field values
[Source: docs/architecture/08-security-performance.md#audit-performance]

### Accessibility Requirements  
**Edit Form Accessibility**:
- Change indicators announced to VoiceOver: "Field modified"
- Unsaved changes warning: "3 unsaved changes"
- Conflict resolution UI with descriptive labels
- History navigation with timeline scrubbing
- Keyboard shortcuts for common edit actions
[Source: docs/architecture/10-coding-standards.md#edit-accessibility]

### Error Handling and Recovery
**Resilience Patterns**:
- Automatic save drafts during long edit sessions
- Network failure recovery with local queuing
- Partial update success with user notification
- Change log corruption recovery mechanisms
- User data protection during sync conflicts
[Source: docs/architecture/08-security-performance.md#error-handling]

## Testing

### Testing Framework and Concurrency
**Concurrency Testing**: Swift Testing with structured concurrency
**Conflict Simulation**: Mock CloudKit with programmed conflicts
**State Testing**: Observable state changes with expectations
**UI Testing**: ViewInspector with edit workflow validation
[Source: docs/architecture/09-testing-strategy.md#concurrency-testing]

### Test File Structure
```
PatientRecordsTests/
├── Domain/
│   ├── ChangeTrackingTests.swift
│   └── UpdateValidatorTests.swift
├── Infrastructure/
│   ├── PatientSyncServiceTests.swift
│   └── ChangeLogRepositoryTests.swift
├── Presentation/
│   ├── PatientEditViewTests.swift
│   ├── PatientHistoryViewTests.swift
│   └── ConflictResolutionTests.swift
└── Concurrency/
    ├── SimultaneousEditTests.swift
    └── SyncConflictTests.swift
```

### Concurrency Test Patterns
```swift
@Test("Simultaneous patient edits")
func testConcurrentEdits() async throws {
    let patient = createTestPatient()
    
    // Simulate two devices editing simultaneously
    async let edit1: Void = patientService.updateName(patient.id, "Updated Name 1")
    async let edit2: Void = patientService.updateBreed(patient.id, "Updated Breed")
    
    // Both should succeed without conflicts
    let (_, _) = try await (edit1, edit2)
    
    // Verify both changes are preserved
    let updatedPatient = try await patientService.getPatient(patient.id)
    #expect(updatedPatient.name == "Updated Name 1")
    #expect(updatedPatient.breed == "Updated Breed")
}

@Test("Conflict resolution workflow")
func testConflictResolution() async throws {
    // Create version conflict scenario
    let conflict = createMockConflict()
    let resolution = await conflictResolver.resolve(conflict)
    
    #expect(resolution.strategy == .manual)
    #expect(resolution.mergedChanges.count > 0)
}
```

### Change Tracking Accuracy Tests
```swift
@Test("Change log completeness")
func testChangeLogAccuracy() throws {
    let patient = createTestPatient()
    let originalName = patient.name
    
    // Update patient name
    patient.name = "New Name"
    try patientService.save(patient)
    
    // Verify change log entry
    let changes = try changeLogService.getChanges(for: patient.id)
    #expect(changes.count == 1)
    #expect(changes[0].fieldName == "name")
    #expect(changes[0].oldValue == originalName)
    #expect(changes[0].newValue == "New Name")
}
```

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-22 | 1.0 | Initial story creation from Epic 1.3 | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*This section will be populated by the QA Agent after story completion*