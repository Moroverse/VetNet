# Story 2.1: Enhanced Router State Management with StateKit Events

## Status
In Progress - Design Phase

## Story
**As a** VetNet developer,  
**I want to** implement event-driven router state management using StateKit EventBroker,  
**So that** navigation flows are more predictable, testable, and provide better debugging capabilities while eliminating callback-based coupling.

## Iteration Plan

### Iteration 1: StateKit EventBroker Integration
- Integrate StateKit EventBroker into router architecture
- Define router-specific events for navigation state changes
- Replace callback-based refresh patterns with event publishing

### Iteration 2: Structured Router State Machine  
- Implement comprehensive RouterState enum with all navigation states
- Add state transition validation and logging
- Ensure thread-safe state management with proper actor isolation

### Iteration 3: Enhanced Testing & Debugging
- Create event-based router testing utilities
- Add comprehensive state transition logging
- Implement router state debugging tools

## Acceptance Criteria

### Iteration 1: StateKit EventBroker Foundation

1. **Event Definition Architecture**
   - Define specific router events implementing StateKit's `Event` directly:
     - `FormPresentationRequested(mode: PatientFormMode)`
     - `FormPresentationCompleted(mode: PatientFormMode, result: PatientFormResult)`
     - `NavigationRequested(route: PatientRoute)`
     - `NavigationCompleted(route: PatientRoute)`
     - `RouterStateChanged(from: RouterState, to: RouterState)`
   - All events include proper metadata (eventId, timestamp, version)
   - Evaluate `RouterEvent` protocol only if shared behavior emerges across event types

2. **EventBroker Integration**
   - Inject StateKit EventBroker into router via FactoryKit
   - Replace `onPatientListNeedsRefresh` callback with event publishing
   - Ensure proper event publishing in all router methods

3. **Event Subscription Pattern**
   - Components directly use `EventBroker` to subscribe to router events
   - Update `PatientListViewModel` to subscribe via injected `EventBroker`
   - Implement proper subscription lifecycle management with stored `EventSubscription`

### Iteration 2: Router State Machine Implementation

1. **Comprehensive RouterState Definition**
   - Define all possible router states:
     ```swift
     enum RouterState: Sendable, Hashable {
         case idle
         case presentingForm(PatientFormMode, context: PresentationContext)
         case processingFormResult(PatientFormResult, mode: PatientFormMode)
         case navigating(to: PatientRoute, from: PatientRoute?)
         case navigationCompleted(PatientRoute)
         case error(RouterError, context: String)
     }
     ```
   - Include rich context information for debugging and analytics

2. **State Transition Management**
   - Implement state transition validation logic
   - Add comprehensive state transition logging
   - Ensure atomic state changes with proper concurrency handling
   - Publish `RouterStateChanged` events on every state transition

3. **Actor-Safe State Management**
   - Ensure all state changes happen on MainActor
   - Use `@MainActor` isolation for router state properties
   - Implement proper synchronization for concurrent navigation requests

### Iteration 3: Testing & Debugging Enhancement

1. **Event-Based Router Testing**
   - Create `MockEventBroker` for testing router event flows
   - Implement `RouterEventCapture` utility for test assertions
   - Add comprehensive test coverage for all router state transitions
   - Test event publishing and subscription patterns

2. **Router State Debugging**
   - Add structured logging for all state transitions
   - Create debug UI for router state visualization (DEBUG builds only)
   - Implement router state history tracking for debugging
   - Add performance metrics for navigation timing

3. **Integration Testing**
   - Test complete navigation flows with event verification
   - Ensure proper cleanup of event subscriptions
   - Validate state consistency across navigation scenarios
   - Test error recovery and state reset capabilities

## Tasks / Subtasks

### Iteration 1: EventBroker Foundation
- [x] **Task 1.1: Create RouterEventBroker Implementation**
  - [x] Create `RouterEventBroker` class implementing StateKit's `EventBroker` protocol
  - [x] Implement thread-safe subscription management with actor isolation
  - [x] Add comprehensive logging for event publishing and subscription
  - [x] Register RouterEventBroker in Container+VetNet with proper scoping

- [x] **Task 1.2: Router Event Architecture**
  - [x] Define specific router events implementing StateKit's `Event` directly (FormPresentation*, Navigation*, RouterStateChanged)
  - [x] Add proper event metadata and context information (eventId, timestamp, version)
  - [x] Evaluate need for `RouterEvent` protocol based on shared behavior requirements
  - [x] Create event factory methods for consistent event creation if protocol is justified

- [ ] **Task 1.3: EventBroker Integration**
  - [x] Add EventBroker injection to router via FactoryKit
  - [x] Replace callback patterns with event publishing in router methods
  - [x] Ensure proper error handling in event publishing
  - [x] Add event publishing to all navigation and form presentation methods

- [ ] **Task 1.4: Event Subscription Implementation**
  - [x] Inject `EventBroker` into ViewModels via FactoryKit
  - [x] Update `PatientListViewModel` to subscribe to router events
  - [x] Store `EventSubscription` and handle cleanup in deinit
  - [x] Add proper memory management with weak self in handlers

### Iteration 2: Router State Machine
- [ ] **Task 2.1: RouterState Implementation**
  - [ ] Define comprehensive RouterState enum with all navigation states
  - [ ] Add rich context information to each state
  - [ ] Implement state equality and hashing for proper comparison
  - [ ] Create state description methods for debugging

- [ ] **Task 2.2: State Transition Logic**
  - [ ] Implement state transition validation rules
  - [ ] Add atomic state change methods with proper locking
  - [ ] Create state transition history for debugging
  - [ ] Add comprehensive state transition logging

- [ ] **Task 2.3: Actor-Safe State Management**
  - [ ] Ensure MainActor isolation for all state properties
  - [ ] Implement proper synchronization for concurrent requests
  - [ ] Add state change publishing with RouterStateChanged events
  - [ ] Test thread safety of state management

### Iteration 3: Testing & Debugging
- [ ] **Task 3.1: Router Testing Infrastructure**
  - [ ] Create MockEventBroker for isolated router testing
  - [ ] Implement RouterEventCapture utility for test assertions
  - [ ] Add comprehensive test coverage for all router methods
  - [ ] Create test utilities for state transition verification

- [ ] **Task 3.2: Debugging & Monitoring**
  - [ ] Add structured logging for all router operations
  - [ ] Create debug UI for router state visualization (DEBUG only)
  - [ ] Implement router state history tracking
  - [ ] Add performance metrics and timing analysis

- [ ] **Task 3.3: Integration & Performance**
  - [ ] Test complete navigation flows with event verification
  - [ ] Validate proper cleanup of event subscriptions
  - [ ] Ensure state consistency across complex scenarios
  - [ ] Performance test event publishing and subscription overhead

## Dev Notes

### EventBroker Implementation Strategy

**Key Decision**: StateKit provides only **protocols** (Event, EventSubscription, EventBroker), not a concrete implementation. We need to create our own EventBroker implementation.

**Architectural Approach**: **Centralized Infrastructure EventBroker**

**Implementation Strategy: Dictionary-Based with Type Erasure** (Recommended)

```swift
// Infrastructure/Services/RouterEventBroker.swift
import Foundation
import StateKit

@MainActor
final class RouterEventBroker: EventBroker {
    // Type-erased subscription storage keyed by event type
    private var subscriptions: [ObjectIdentifier: [AnySubscription]] = [:]
    private let logger: LoggingService
    
    init(logger: LoggingService) {
        self.logger = logger
    }
    
    func publish(_ event: some Event) {
        let eventType = type(of: event)
        let key = ObjectIdentifier(eventType)
        
        logger.debug("Publishing event: \(eventType)")
        
        // Get all subscriptions for this event type
        guard let typeSubscriptions = subscriptions[key] else { return }
        
        // Notify all subscribers
        for subscription in typeSubscriptions {
            subscription.notify(event)
        }
    }
    
    func subscribe<T: Event>(_ eventType: T.Type, handler: @escaping @Sendable (T) -> Void) -> EventSubscription {
        let key = ObjectIdentifier(eventType)
        let subscriptionId = UUID()
        
        logger.debug("New subscription for: \(eventType)")
        
        // Create type-erased subscription wrapper
        let subscription = AnySubscription(id: subscriptionId) { event in
            if let typedEvent = event as? T {
                handler(typedEvent)
            }
        }
        
        // Store subscription
        subscriptions[key, default: []].append(subscription)
        
        // Return subscription handle for cleanup
        return RouterEventSubscription { [weak self] in
            self?.unsubscribe(id: subscriptionId, for: key)
        }
    }
    
    private func unsubscribe(id: UUID, for key: ObjectIdentifier) {
        subscriptions[key]?.removeAll { $0.id == id }
        
        // Clean up empty arrays
        if subscriptions[key]?.isEmpty == true {
            subscriptions[key] = nil
        }
        
        logger.debug("Unsubscribed: \(id)")
    }
}

// Type-erased subscription wrapper
private struct AnySubscription {
    let id: UUID
    private let handler: @Sendable (any Event) -> Void
    
    init(id: UUID, handler: @escaping @Sendable (any Event) -> Void) {
        self.id = id
        self.handler = handler
    }
    
    func notify(_ event: any Event) {
        handler(event)
    }
}

// Concrete EventSubscription implementation
private struct RouterEventSubscription: EventSubscription {
    private let unsubscribeHandler: () -> Void
    
    init(unsubscribeHandler: @escaping () -> Void) {
        self.unsubscribeHandler = unsubscribeHandler
    }
    
    func unsubscribe() {
        unsubscribeHandler()
    }
}

// Infrastructure/Configuration/Container+VetNet.swift
extension Container {
    @MainActor
    var routerEventBroker: Factory<EventBroker> {
        self {
            RouterEventBroker(logger: self.loggingService())
        }
        .singleton  // Single instance for entire app lifecycle
    }
}

// Update router factory to inject EventBroker
extension Container {
    @MainActor
    var patientManagementRouter: Factory<PatientManagementFormRouter> {
        self {
            PatientManagementFormRouter(eventBroker: self.routerEventBroker())
        }
        .cached
    }
}
```

**Why Dictionary-Based Implementation?**
1. **Type Safety**: Maintains type safety through generics and type erasure
2. **Performance**: O(1) lookup for event type subscriptions
3. **Memory Efficient**: Automatic cleanup of empty subscription arrays
4. **Simple**: Easier to understand and debug than Combine or NotificationCenter
5. **SwiftUI Compatible**: Works perfectly with @MainActor isolation

**Alternatives Considered:**

**Option 1: Modern NotificationCenter.Message API** (Valid Alternative)
```swift
// Type-safe message definition
struct RouterStateChangedMessage: NotificationCenter.MainActorMessage {
    typealias Subject = PatientManagementFormRouter
    let from: RouterState
    let to: RouterState
}

// Publishing
NotificationCenter.default.post(RouterStateChangedMessage(from: oldState, to: newState), subject: self)

// Subscribing
notificationToken = NotificationCenter.default.addObserver(
    for: RouterStateChangedMessage.self
) { message in
    // Handle state change
}
```
**Pros**:
- Type-safe with modern Message API (iOS 16.4+)
- Already used in codebase (FeatureFlagDidChangeMessage)
- Built-in MainActor isolation support
- Apple-supported, will evolve with platform

**Cons**:
- Requires conforming to StateKit's EventBroker protocol (adapter needed)
- Less control over subscription management internals
- Harder to mock for testing compared to custom implementation

**Option 2: Combine Publishers**:
- Adds unnecessary complexity for simple event broadcasting
- Requires managing cancellables alongside subscriptions
- Overkill for our use case (we don't need operators, backpressure, etc.)

**Option 3: AsyncStream/AsyncSequence**:
- Would require separate streams for each event type
- More complex subscription management
- Doesn't fit well with the StateKit Event protocol design

**✅ Dictionary-Based Approach** (Recommended):
- Perfect balance of simplicity and functionality
- Direct implementation of StateKit protocols
- Easier to test with mock implementations
- Full control over implementation details
- No adapter layer needed

**Final Decision**: While NotificationCenter.Message API is a valid choice (especially since we're already using it), the dictionary-based approach is recommended because:
1. **Direct StateKit Integration**: No adapter needed between NotificationCenter and StateKit protocols
2. **Testing Simplicity**: MockEventBroker is simpler than mocking NotificationCenter
3. **Consistency**: StateKit events stay within StateKit's design philosophy
4. **Flexibility**: Can evolve implementation without platform constraints

**Alternative Implementation Using NotificationCenter** (If Preferred):
```swift
// If you prefer consistency with existing FeatureFlagService pattern
@MainActor
final class NotificationCenterEventBroker: EventBroker {
    private let logger: LoggingService
    private var observations: [UUID: NotificationCenter.ObservationToken] = [:]
    
    func publish(_ event: some Event) {
        // Convert StateKit Event to NotificationCenter.Message
        let message = RouterEventMessage(event: event)
        NotificationCenter.default.post(message, subject: self)
        logger.debug("Published event: \(type(of: event))")
    }
    
    func subscribe<T: Event>(_ eventType: T.Type, handler: @escaping @Sendable (T) -> Void) -> EventSubscription {
        let id = UUID()
        let token = NotificationCenter.default.addObserver(
            for: RouterEventMessage.self,
            subject: self
        ) { message in
            if let typedEvent = message.event as? T {
                handler(typedEvent)
            }
        }
        
        observations[id] = token
        
        return NotificationCenterEventSubscription { [weak self] in
            if let token = self?.observations.removeValue(forKey: id) {
                NotificationCenter.default.removeObserver(token)
            }
        }
    }
}

struct RouterEventMessage: NotificationCenter.MainActorMessage {
    typealias Subject = NotificationCenterEventBroker
    let event: any Event
}
```

### Leveraging StateKit Event Protocols

**Important Clarification**: We only need StateKit's existing protocols:
- **Event**: Protocol for our router events (implemented directly)
- **EventSubscription**: Returned from subscribe() for lifecycle management  
- **EventBroker**: Protocol our `RouterEventBroker` implements (combines `EventPublisher` & `EventSubscriber`)

**RouterEvent Protocol Decision**:
- Start with **direct Event implementation** for simplicity
- Only introduce `RouterEvent` protocol if shared behavior emerges:
  - Event correlation (linking navigation chains)
  - Shared debugging utilities
  - Common performance metrics
- Avoid protocol over-engineering for simple data containers

**Why No RouterEventSubscriber Protocol?**
- `EventSubscriber` is for **providers** of subscription capability (our EventBroker)
- Components that **consume** events don't need a special protocol
- They just need access to the EventBroker and call `subscribe()` directly
- This keeps the architecture simpler and more flexible

### Architecture Benefits
- **Decoupling**: Components react to events rather than direct callbacks
- **Testability**: Event-based testing is more predictable and isolated
- **Debugging**: Comprehensive event logging provides better debugging capabilities
- **Scalability**: Easy to add new components that react to router events
- **Consistency**: Structured state management prevents invalid state transitions

### Migration Strategy

**Phase 1** (Iteration 1): Additive changes only
```swift
// Existing callback pattern remains
var onPatientListNeedsRefresh: (() async -> Void)?

// New event-based pattern added alongside
private let eventBroker: EventBroker

func createPatient() async -> PatientFormResult {
    await eventBroker.publish(FormPresentationRequested(mode: .create))
    let result = await presentForm(.create)
    await eventBroker.publish(FormPresentationCompleted(mode: .create, result: result))
    
    // Keep existing callback during transition
    if case .created = result {
        await onPatientListNeedsRefresh?()
    }
    
    return result
}
```

**Phase 2** (Iteration 2): State machine implementation
```swift
@MainActor
@Observable
final class PatientManagementFormRouter: BaseFormRouter<PatientFormMode, PatientFormResult> {
    private(set) var state: RouterState = .idle
    private let eventBroker: EventBroker
    private var stateHistory: [RouterStateTransition] = []
    
    private func transitionTo(_ newState: RouterState) {
        let oldState = state
        state = newState
        
        let transition = RouterStateTransition(from: oldState, to: newState, timestamp: Date())
        stateHistory.append(transition)
        
        eventBroker.publish(RouterStateChanged(from: oldState, to: newState))
        logStateTransition(transition)
    }
}
```

**Phase 3** (Iteration 3): Remove callback patterns
```swift
// Remove deprecated callback property
// var onPatientListNeedsRefresh: (() async -> Void)? // ❌ Removed

// Components now subscribe to events directly via EventBroker
@Observable
final class PatientListViewModel {
    @Injected(\.routerEventBroker) private var eventBroker
    private var eventSubscription: EventSubscription?
    
    init() {
        setupEventSubscriptions()
    }
    
    private func setupEventSubscriptions() {
        eventSubscription = eventBroker.subscribe(FormPresentationCompleted.self) { [weak self] event in
            Task { @MainActor in
                await self?.handleFormCompletion(event)
            }
        }
    }
    
    deinit {
        eventSubscription?.unsubscribe()
    }
}
```

### Event Design Principles

1. **Rich Context**: Events include all necessary context for debugging
2. **Type Safety**: Leverage Swift's type system for event validation
3. **Immutability**: Events are immutable value types
4. **Metadata**: All events include standard metadata (ID, timestamp, version)
5. **Granularity**: Events are fine-grained for precise subscription control
6. **Pragmatic Architecture**: Start simple with direct Event implementation, add protocol layers only when justified by shared behavior

### Testing Strategy

**Mock EventBroker Implementation**:
```swift
// Tests/Mocks/MockEventBroker.swift
final class MockEventBroker: EventBroker {
    var publishedEvents: [any Event] = []
    var subscriptionCount = 0
    
    func publish(_ event: some Event) {
        publishedEvents.append(event)
    }
    
    func subscribe<T: Event>(_ eventType: T.Type, handler: @escaping @Sendable (T) -> Void) -> EventSubscription {
        subscriptionCount += 1
        
        // For testing, immediately call handler with any matching published events
        for event in publishedEvents {
            if let typedEvent = event as? T {
                handler(typedEvent)
            }
        }
        
        return MockEventSubscription { [weak self] in
            self?.subscriptionCount -= 1
        }
    }
    
    func reset() {
        publishedEvents.removeAll()
        subscriptionCount = 0
    }
}

private struct MockEventSubscription: EventSubscription {
    let onUnsubscribe: () -> Void
    
    func unsubscribe() {
        onUnsubscribe()
    }
}
```

**Event-Driven Testing**:
```swift
@Test("Router publishes correct events during patient creation")
func testPatientCreationEventFlow() async throws {
    let mockBroker = MockEventBroker()
    let router = PatientManagementFormRouter(eventBroker: mockBroker)
    
    await router.createPatient()
    
    // Verify event sequence
    #expect(mockBroker.publishedEvents.count == 2)
    #expect(mockBroker.publishedEvents[0] is FormPresentationRequested)
    #expect(mockBroker.publishedEvents[1] is FormPresentationCompleted)
    
    // Verify event content
    let presentationEvent = mockBroker.publishedEvents[0] as! FormPresentationRequested
    #expect(presentationEvent.mode == .create)
}
```

**State Transition Testing**:
```swift
@Test("Router state transitions correctly during navigation")
func testRouterStateTransitions() async throws {
    let router = PatientManagementFormRouter()
    let stateCapture = RouterStateCapture(router: router)
    
    await router.navigateToPatientDetail(testPatient)
    
    #expect(stateCapture.transitions == [
        (.idle, .navigating(to: .patientDetail(testPatient), from: nil)),
        (.navigating, .navigationCompleted(.patientDetail(testPatient)))
    ])
}
```

## Implementation Timeline

| Week | Focus | Deliverables |
|------|-------|--------------|
| 1 | EventBroker Integration | Router events defined, EventBroker injected |
| 2 | State Machine Core | RouterState enum, basic state transitions |
| 3 | State Management | Complete state machine, event publishing |
| 4 | Testing Infrastructure | Mock utilities, comprehensive test coverage |
| 5 | Debugging Tools | State visualization, logging, performance metrics |
| 6 | Integration & Polish | End-to-end testing, performance optimization |

## Success Metrics

- **Event Coverage**: 100% of router operations publish appropriate events
- **State Consistency**: Zero invalid state transitions in testing
- **Test Coverage**: >95% coverage for router state management
- **Performance**: <1ms overhead for event publishing and state transitions
- **Memory Usage**: Zero memory leaks in event subscription lifecycle
- **Debugging**: Complete state transition history available for debugging

## Related Documentation

- **[SwiftUIRouting Module](../../Modules/SwiftUIRouting/)**: Custom navigation framework
- **[FactoryKit Integration](../architecture/swift-best-practices.md)**: Dependency injection patterns
- **[StateKit Documentation](../../Tuist/.build/checkouts/state-kit/)**: Event handling capabilities
- **[Testing Strategy](../architecture/09-testing-strategy.md)**: Comprehensive testing approach

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-14 | 1.0 | Initial story with StateKit EventBroker integration plan | Architect Agent |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.1

### Debug Log References
- None yet

### Completion Notes
- Task 1.3 Complete: EventBroker integration into router
- Fixed all test compilation errors
- All tests passing successfully

### File List
- App/Sources/Infrastructure/Configuration/Container+VetNet.swift (updated - added RouterEventFactory registration)
- App/Sources/Features/PatientManagement/Navigation/PatientManagementFormRouter.swift (updated - added EventBroker injection)
- App/Sources/Features/PatientManagement/Navigation/RouterEventFactory.swift (updated - uses @Injected)
- App/Sources/Infrastructure/Services/RouterEventBroker.swift (existing)
- App/Tests/Mocks/MockEventBroker.swift (created)
- App/Tests/UnitTests/PatientManagementTests/PatientManagementFormRouterTests.swift (updated - added EventBroker tests)

### Testing
- Unit tests for EventBroker injection
- Integration tests for event publishing