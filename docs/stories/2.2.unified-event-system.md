# Story 2.2: Unified Event System Architecture

## Status
Planned - Dependent on Story 2.1

## Story
**As a** VetNet developer,  
**I want to** implement a unified event system using the EventBroker pattern across all application domains,  
**So that** all event-driven communication uses a consistent, testable, and debuggable pattern throughout the application.

## Dependencies
- Story 2.1: Enhanced Router State Management with StateKit Events (must be completed first)
- Existing EventBroker implementation from Story 2.1
- Current FeatureFlagDidChangeMessage implementation using NotificationCenter

## Iteration Plan

### Iteration 1: Event Domain Architecture
- Define event categories and protocols for different domains
- Create comprehensive event types for all app domains
- Establish event naming conventions and structure

### Iteration 2: EventBroker Enhancement
- Extend EventBroker with filtering and priority capabilities
- Add event metrics and debugging features
- Implement event replay for debugging

### Iteration 3: Migration from NotificationCenter
- Migrate FeatureFlagService to EventBroker
- Update all NotificationCenter consumers to EventBroker
- Remove legacy notification patterns

### Iteration 4: System-Wide Integration
- Integrate data sync events with EventBroker
- Add patient update events beyond router scope
- Implement system events (network, background tasks)

## Acceptance Criteria

### Iteration 1: Event Domain Architecture

1. **Event Category Definition**
   - Create event protocol hierarchy:
     ```swift
     protocol RouterEvent: Event {}
     protocol DataEvent: Event {}
     protocol SystemEvent: Event {}
     protocol UserActionEvent: Event {}
     protocol FeatureEvent: Event {}
     ```
   - All events properly categorized
   - Clear documentation for each category

2. **Comprehensive Event Types**
   - Feature Flag Events:
     - `FeatureFlagChangedEvent` with old/new values and source
     - `FeatureFlagBulkUpdateEvent` for multiple flag changes
   - Data Sync Events:
     - `DataSyncStartedEvent`
     - `DataSyncProgressEvent` with percentage
     - `DataSyncCompletedEvent` with statistics
     - `DataSyncFailedEvent` with error details
   - Patient Events:
     - `PatientUpdatedEvent` with change details
     - `PatientBulkUpdateEvent` for batch operations
     - `PatientDeletedEvent` with cascade information
   - System Events:
     - `NetworkStatusChangedEvent`
     - `MemoryWarningEvent`
     - `BackgroundTaskEvent`
     - `AppLifecycleEvent`

3. **Event Standards**
   - All events include standard metadata (eventId, timestamp, version)
   - Events are immutable value types
   - Rich context for debugging and analytics
   - Proper Sendable conformance

### Iteration 2: EventBroker Enhancement

1. **Advanced Subscription Features**
   - Priority-based event handling:
     ```swift
     func subscribePriority<T: Event>(
         _ eventType: T.Type,
         priority: EventPriority,
         handler: @escaping @Sendable (T) -> Void
     ) -> EventSubscription
     ```
   - Filtered subscriptions:
     ```swift
     func subscribe<T: Event>(
         _ eventType: T.Type,
         filter: @escaping (T) -> Bool,
         handler: @escaping @Sendable (T) -> Void
     ) -> EventSubscription
     ```
   - Category-based subscriptions for event groups

2. **Event Metrics & Monitoring**
   - Event frequency tracking
   - Subscription count monitoring
   - Performance metrics (publish/dispatch time)
   - Memory usage tracking
   - Dead letter queue for failed event handling

3. **Debugging Capabilities**
   - Event history with configurable retention
   - Event replay for debugging scenarios
   - Event flow visualization (DEBUG builds)
   - Comprehensive logging with levels
   - Event filtering for noise reduction

### Iteration 3: Migration from NotificationCenter

1. **FeatureFlagService Migration**
   - Update FeatureFlagService to use EventBroker:
     ```swift
     @MainActor
     final class FeatureFlagService {
         @Injected(\.eventBroker) private var eventBroker
         
         func updateFlag(_ flag: FeatureFlag, value: Bool) {
             let oldValue = currentValue(for: flag)
             UserDefaults.standard.set(value, forKey: flag.rawValue)
             
             eventBroker.publish(FeatureFlagChangedEvent(
                 flag: flag,
                 oldValue: oldValue,
                 newValue: value,
                 source: .userToggle
             ))
         }
     }
     ```
   - Maintain backward compatibility during transition
   - Update all consumers to use EventBroker subscriptions

2. **Consumer Migration**
   - Identify all NotificationCenter observers
   - Update each to use EventBroker subscriptions
   - Ensure proper subscription lifecycle management
   - Add memory leak prevention with weak self

3. **Legacy Cleanup**
   - Remove NotificationCenter.Message definitions
   - Delete observation token management code
   - Update documentation and examples
   - Ensure zero NotificationCenter usage remains

### Iteration 4: System-Wide Integration

1. **Data Layer Integration**
   - SwiftData operations publish DataEvents
   - Repository implementations emit events
   - Batch operations use BulkUpdateEvents
   - Sync status tracked via events

2. **UI Layer Integration**
   - ViewModels subscribe to relevant events
   - Proper subscription cleanup in deinit
   - Event-driven UI updates
   - Loading states managed via events

3. **Background Task Integration**
   - Background sync publishes progress events
   - Network reachability publishes status events
   - CloudKit sync emits sync events
   - Push notification handling via events

## Tasks / Subtasks

### Iteration 1: Event Domain Architecture
- [ ] **Task 1.1: Define Event Protocol Hierarchy**
  - [ ] Create base event protocols for each domain
  - [ ] Document purpose and usage of each category
  - [ ] Establish event naming conventions
  - [ ] Add Sendable conformance requirements

- [ ] **Task 1.2: Implement Feature Events**
  - [ ] Create FeatureFlagChangedEvent with full context
  - [ ] Add FeatureFlagBulkUpdateEvent for batch changes
  - [ ] Include source tracking (user, remote, debug)
  - [ ] Add proper equatable and hashable conformance

- [ ] **Task 1.3: Implement Data Events**
  - [ ] Create patient CRUD events
  - [ ] Add sync lifecycle events
  - [ ] Include batch operation events
  - [ ] Add cascade tracking for deletions

- [ ] **Task 1.4: Implement System Events**
  - [ ] Create network status events
  - [ ] Add app lifecycle events
  - [ ] Include memory warning events
  - [ ] Add background task events

### Iteration 2: EventBroker Enhancement
- [ ] **Task 2.1: Priority Queue Implementation**
  - [ ] Add EventPriority enum (critical, high, normal, low)
  - [ ] Implement priority-based dispatch queue
  - [ ] Ensure FIFO within same priority level
  - [ ] Add tests for priority ordering

- [ ] **Task 2.2: Event Filtering System**
  - [ ] Implement predicate-based filtering
  - [ ] Add category-based filtering
  - [ ] Create noise reduction filters
  - [ ] Add configurable filter chains

- [ ] **Task 2.3: Metrics & Monitoring**
  - [ ] Implement EventMetrics class
  - [ ] Track publish/subscribe counts
  - [ ] Monitor dispatch performance
  - [ ] Add memory usage tracking

- [ ] **Task 2.4: Debugging Tools**
  - [ ] Implement event history with ring buffer
  - [ ] Add event replay capability
  - [ ] Create debug UI for event flow
  - [ ] Add comprehensive logging

### Iteration 3: NotificationCenter Migration
- [ ] **Task 3.1: Dual Publishing Phase**
  - [ ] Update FeatureFlagService with EventBroker
  - [ ] Maintain NotificationCenter publishing temporarily
  - [ ] Add migration flag for gradual rollout
  - [ ] Test both paths work correctly

- [ ] **Task 3.2: Consumer Migration**
  - [ ] Audit all NotificationCenter observers
  - [ ] Update PatientListViewModel subscriptions
  - [ ] Migrate SettingsViewModel observers
  - [ ] Update all other consumers

- [ ] **Task 3.3: Cleanup & Removal**
  - [ ] Remove NotificationCenter publishing
  - [ ] Delete Message type definitions
  - [ ] Clean up observation tokens
  - [ ] Update all documentation

### Iteration 4: System Integration
- [ ] **Task 4.1: Repository Integration**
  - [ ] Add event publishing to PatientRepository
  - [ ] Emit events from AppointmentRepository
  - [ ] Include batch operation events
  - [ ] Add transaction boundaries

- [ ] **Task 4.2: Sync Service Integration**
  - [ ] Publish CloudKit sync events
  - [ ] Emit progress during large syncs
  - [ ] Add conflict resolution events
  - [ ] Include error recovery events

- [ ] **Task 4.3: Background Task Integration**
  - [ ] Integrate with BackgroundTaskScheduler
  - [ ] Publish task lifecycle events
  - [ ] Add progress reporting
  - [ ] Include completion statistics

## Dev Notes

### Architectural Decision: Unified EventBroker

**Key Decision**: Use the dictionary-based EventBroker from Story 2.1 as the foundation for ALL app events, not just router events.

**Benefits**:
1. **Consistency**: Single pattern for all event-driven communication
2. **Testability**: One MockEventBroker for all testing scenarios
3. **Performance**: Centralized optimization opportunities
4. **Debugging**: Complete event flow visibility
5. **Type Safety**: Leverages Swift's type system throughout

### Enhanced EventBroker Implementation

Building on Story 2.1's foundation:

```swift
// Infrastructure/Services/AppEventBroker.swift
@MainActor
final class AppEventBroker: EventBroker {
    private var subscriptions: [ObjectIdentifier: [AnySubscription]] = [:]
    private let logger: LoggingService
    
    // New capabilities for app-wide usage
    private var eventFilters: [EventFilter] = []
    private var eventMetrics = EventMetrics()
    private var eventHistory = CircularBuffer<EventRecord>(capacity: 1000)
    private let priorityQueue = PriorityEventQueue()
    
    init(logger: LoggingService) {
        self.logger = logger
        setupDefaultFilters()
        setupMetricsCollection()
    }
    
    func publish(_ event: some Event) {
        let eventType = type(of: event)
        let key = ObjectIdentifier(eventType)
        
        // Apply filters
        guard shouldPublish(event) else {
            logger.trace("Event filtered: \(eventType)")
            return
        }
        
        // Record in history
        let record = EventRecord(event: event, timestamp: Date())
        eventHistory.append(record)
        
        // Track metrics
        eventMetrics.recordEvent(eventType)
        
        // Log based on event category
        logEvent(event)
        
        // Get subscribers
        guard let typeSubscriptions = subscriptions[key] else { return }
        
        // Dispatch based on priority
        dispatchToSubscribers(event, subscribers: typeSubscriptions)
    }
    
    // Priority-based subscription
    func subscribePriority<T: Event>(
        _ eventType: T.Type,
        priority: EventPriority = .normal,
        handler: @escaping @Sendable (T) -> Void
    ) -> EventSubscription {
        let key = ObjectIdentifier(eventType)
        let subscriptionId = UUID()
        
        let subscription = PrioritySubscription(
            id: subscriptionId,
            priority: priority
        ) { event in
            if let typedEvent = event as? T {
                handler(typedEvent)
            }
        }
        
        // Insert sorted by priority
        subscriptions[key, default: []].append(subscription)
        subscriptions[key]?.sort { $0.priority > $1.priority }
        
        return AppEventSubscription { [weak self] in
            self?.unsubscribe(id: subscriptionId, for: key)
        }
    }
    
    // Filtered subscription
    func subscribe<T: Event>(
        _ eventType: T.Type,
        filter: @escaping (T) -> Bool,
        handler: @escaping @Sendable (T) -> Void
    ) -> EventSubscription {
        subscribe(eventType) { event in
            if filter(event) {
                handler(event)
            }
        }
    }
    
    // Category subscription
    func subscribeToCategory<T: Event>(
        _ category: T.Type,
        handler: @escaping @Sendable (T) -> Void
    ) -> EventSubscription where T: Event {
        subscribe(category, handler: handler)
    }
}

// Event metrics tracking
final class EventMetrics {
    private var eventCounts: [String: Int] = [:]
    private var eventTimings: [String: [TimeInterval]] = [:]
    private let metricsQueue = DispatchQueue(label: "event.metrics")
    
    func recordEvent(_ eventType: Any.Type) {
        let typeName = String(describing: eventType)
        metricsQueue.async {
            self.eventCounts[typeName, default: 0] += 1
        }
    }
    
    func recordTiming(_ eventType: Any.Type, duration: TimeInterval) {
        let typeName = String(describing: eventType)
        metricsQueue.async {
            self.eventTimings[typeName, default: []].append(duration)
        }
    }
    
    func generateReport() -> EventMetricsReport {
        metricsQueue.sync {
            EventMetricsReport(
                eventCounts: eventCounts,
                averageTimings: eventTimings.mapValues { timings in
                    timings.reduce(0, +) / Double(timings.count)
                }
            )
        }
    }
}
```

### Migration Strategy from NotificationCenter

**Phase 1: Parallel Operation** (Week 1-2)
```swift
// Temporary dual publishing in FeatureFlagService
func updateFlag(_ flag: FeatureFlag, value: Bool) {
    let oldValue = currentValue(for: flag)
    
    // Update storage
    UserDefaults.standard.set(value, forKey: flag.rawValue)
    
    // OLD: NotificationCenter (keep temporarily)
    #if DEBUG
    if !Container.shared.useEventBrokerOnly() {
        NotificationCenter.default.post(
            FeatureFlagDidChangeMessage(flag: flag, newValue: value),
            subject: self
        )
    }
    #endif
    
    // NEW: EventBroker (always publish)
    eventBroker.publish(FeatureFlagChangedEvent(
        flag: flag,
        oldValue: oldValue,
        newValue: value,
        source: determineSource()
    ))
}
```

**Phase 2: Consumer Migration** (Week 3-4)
```swift
// Before: NotificationCenter
class PatientListViewModel {
    private var notificationToken: NotificationCenter.ObservationToken?
    
    init() {
        notificationToken = NotificationCenter.default.addObserver(
            for: FeatureFlagDidChangeMessage.self
        ) { [weak self] message in
            self?.handleFeatureFlagChange(message.flag)
        }
    }
}

// After: EventBroker
@Observable
final class PatientListViewModel {
    @Injected(\.eventBroker) private var eventBroker
    private var eventSubscription: EventSubscription?
    
    init() {
        setupEventSubscriptions()
    }
    
    private func setupEventSubscriptions() {
        eventSubscription = eventBroker.subscribe(
            FeatureFlagChangedEvent.self,
            filter: { event in
                // Only care about specific flags
                [.patientManagementV1, .useMockData].contains(event.flag)
            }
        ) { [weak self] event in
            Task { @MainActor in
                await self?.handleFeatureFlagChange(event)
            }
        }
    }
    
    deinit {
        eventSubscription?.unsubscribe()
    }
}
```

**Phase 3: Complete Removal** (Week 5)
- Remove all NotificationCenter.Message types
- Delete observation token management
- Remove dual publishing code
- Update all documentation

### Event Categories and Organization

```swift
// Domain/Events/EventProtocols.swift
import StateKit

// Base category protocols
protocol RouterEvent: Event {}
protocol DataEvent: Event {}
protocol SystemEvent: Event {}
protocol UserActionEvent: Event {}
protocol FeatureEvent: Event {}

// Subcategories
protocol PatientDataEvent: DataEvent {}
protocol AppointmentDataEvent: DataEvent {}
protocol SyncEvent: DataEvent {}
protocol NetworkEvent: SystemEvent {}
protocol LifecycleEvent: SystemEvent {}

// Event priority for critical events
enum EventPriority: Int, Comparable {
    case critical = 1000
    case high = 100
    case normal = 10
    case low = 1
    
    static func < (lhs: EventPriority, rhs: EventPriority) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}
```

### Testing Strategy

**Comprehensive Mock for Testing**:
```swift
// Tests/Mocks/MockAppEventBroker.swift
final class MockAppEventBroker: EventBroker {
    var publishedEvents: [any Event] = []
    var subscriptionsByType: [String: Int] = [:]
    var eventFilter: ((any Event) -> Bool)?
    
    // Control event delivery
    var deliveryMode: DeliveryMode = .immediate
    enum DeliveryMode {
        case immediate
        case manual
        case delayed(TimeInterval)
    }
    
    func publish(_ event: some Event) {
        if let filter = eventFilter, !filter(event) {
            return
        }
        
        publishedEvents.append(event)
        
        switch deliveryMode {
        case .immediate:
            deliverToSubscribers(event)
        case .manual:
            // Wait for manual trigger
            break
        case .delayed(let interval):
            Task {
                try? await Task.sleep(for: .seconds(interval))
                await deliverToSubscribers(event)
            }
        }
    }
    
    func expectEvent<T: Event>(
        ofType type: T.Type,
        matching predicate: (T) -> Bool = { _ in true }
    ) -> T? {
        publishedEvents.compactMap { $0 as? T }.first(where: predicate)
    }
    
    func reset() {
        publishedEvents.removeAll()
        subscriptionsByType.removeAll()
    }
}
```

**Integration Testing**:
```swift
@Test("Feature flag change triggers appropriate events")
func testFeatureFlagEventFlow() async throws {
    let mockBroker = MockAppEventBroker()
    Container.shared.eventBroker.register { mockBroker }
    
    let service = FeatureFlagService()
    let viewModel = PatientListViewModel()
    
    // Change feature flag
    service.updateFlag(.useMockData, value: true)
    
    // Verify event was published
    let event = mockBroker.expectEvent(ofType: FeatureFlagChangedEvent.self) { event in
        event.flag == .useMockData && event.newValue == true
    }
    
    #expect(event != nil)
    #expect(event?.oldValue == false)
    #expect(event?.source == .userToggle)
    
    // Verify view model reacted
    await Task.yield()
    #expect(viewModel.isUsingMockData == true)
}
```

### Performance Considerations

1. **Event Filtering**: Apply filters early to reduce unnecessary processing
2. **Subscription Management**: Use weak references to prevent retain cycles
3. **Priority Dispatch**: Critical events processed before normal events
4. **Metrics Collection**: Async/background collection to avoid blocking
5. **History Management**: Ring buffer prevents unbounded memory growth

### Container Registration

```swift
// Infrastructure/Configuration/Container+VetNet.swift
extension Container {
    // Single EventBroker for entire application
    @MainActor
    var eventBroker: Factory<EventBroker> {
        self { 
            AppEventBroker(logger: self.loggingService())
        }
        .singleton  // One instance for all events
        .onPreview {
            MockAppEventBroker()  // Use mock in previews
        }
        .onTest {
            MockAppEventBroker()  // Use mock in tests
        }
    }
    
    // All services use the same EventBroker
    var featureFlagService: Factory<FeatureFlagService> {
        self { 
            FeatureFlagService(eventBroker: self.eventBroker())
        }
        .singleton
    }
    
    var patientRepository: Factory<PatientRepository> {
        self { 
            SwiftDataPatientRepository(
                modelContext: self.modelContext(),
                eventBroker: self.eventBroker()
            )
        }
        .cached
    }
}
```

## Implementation Timeline

| Week | Focus | Deliverables |
|------|-------|--------------|
| 1 | Event Architecture | Event protocols, categories, comprehensive event types |
| 2 | EventBroker Enhancement | Priority queues, filtering, metrics |
| 3 | Migration Preparation | Dual publishing, backward compatibility |
| 4 | Consumer Migration | Update all ViewModels and services |
| 5 | Cleanup & Testing | Remove NotificationCenter, comprehensive tests |
| 6 | System Integration | Data layer, background tasks, performance tuning |

## Success Metrics

- **Event Coverage**: 100% of NotificationCenter usage migrated
- **Performance**: <0.5ms average event dispatch time
- **Memory**: Zero memory leaks in subscription lifecycle
- **Test Coverage**: >95% coverage for event system
- **Debugging**: Complete event history available in DEBUG builds
- **Consistency**: Zero mixed patterns (no NotificationCenter remaining)

## Benefits

### Immediate Benefits
- **Unified Pattern**: Single approach for all event-driven communication
- **Better Testing**: One MockEventBroker for all scenarios
- **Type Safety**: Compile-time validation of event handling

### Long-term Benefits
- **Scalability**: Easy to add new event types and subscribers
- **Debugging**: Complete visibility into app event flow
- **Performance**: Centralized optimization opportunities
- **Maintainability**: Clear, consistent patterns throughout codebase

## Related Documentation

- **[Story 2.1](2.1.enhanced-router-state-management.md)**: Foundation EventBroker implementation
- **[FactoryKit Integration](../architecture/swift-best-practices.md)**: Dependency injection patterns
- **[StateKit Documentation](../../Tuist/.build/checkouts/state-kit/)**: Event protocol definitions
- **[Testing Strategy](../architecture/09-testing-strategy.md)**: Event testing approaches

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-14 | 1.0 | Initial story for unified event system | Winston (Architect) |